<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns:st1="urn:schemas-microsoft-com:office:smarttags"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=File-List href="static-a-force-for-good-and-evil_files/filelist.xml">
<title>Static - A Force for Good and Evil</title>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="place"/>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="stockticker"/>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="PersonName"/>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Chris Oldwood</o:Author>
  <o:LastAuthor>Chris Oldwood</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>10483</o:TotalTime>
  <o:Created>2014-05-05T19:22:00Z</o:Created>
  <o:LastSaved>2014-05-05T19:22:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>3900</o:Words>
  <o:Characters>22235</o:Characters>
  <o:Company>Co Productions Ltd</o:Company>
  <o:Lines>185</o:Lines>
  <o:Paragraphs>52</o:Paragraphs>
  <o:CharactersWithSpaces>26083</o:CharactersWithSpaces>
  <o:Version>11.9999</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:Compatibility>
   <w:BreakWrappedTables/>
   <w:SnapToGridInCell/>
   <w:WrapTextWithPunct/>
   <w:UseAsianBreakRules/>
   <w:UseWord2002TableStyleRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]--><!--[if !mso]><object
 classid="clsid:38481807-CA0E-42D2-BF39-B33AF135CC4D" id=ieooui></object>
<style>
st1\:*{behavior:url(#ieooui) }
</style>
<![endif]-->
<style>
<!--
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-GB;}
h1
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:16.0pt;
	font-family:Arial;
	mso-font-kerning:16.0pt;
	mso-ansi-language:EN-GB;}
h3
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:13.0pt;
	font-family:Arial;
	mso-ansi-language:EN-GB;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
code
	{font-family:"Courier New";
	mso-ascii-font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Courier New";}
@page Section1
	{size:612.0pt 792.0pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	mso-header-margin:35.4pt;
	mso-footer-margin:35.4pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;
	width: 600px;
	margin-left: auto;
	margin-right: auto;}
 /* List Definitions */
 @list l0
	{mso-list-id:-132;
	mso-list-type:simple;
	mso-list-template-ids:-1877980112;}
@list l0:level1
	{mso-level-tab-stop:74.6pt;
	mso-level-number-position:left;
	margin-left:74.6pt;
	text-indent:-18.0pt;}
@list l1
	{mso-list-id:-131;
	mso-list-type:simple;
	mso-list-template-ids:238311726;}
@list l1:level1
	{mso-level-tab-stop:60.45pt;
	mso-level-number-position:left;
	margin-left:60.45pt;
	text-indent:-18.0pt;}
@list l2
	{mso-list-id:-130;
	mso-list-type:simple;
	mso-list-template-ids:-1850548544;}
@list l2:level1
	{mso-level-tab-stop:46.3pt;
	mso-level-number-position:left;
	margin-left:46.3pt;
	text-indent:-18.0pt;}
@list l3
	{mso-list-id:-129;
	mso-list-type:simple;
	mso-list-template-ids:-1202698734;}
@list l3:level1
	{mso-level-tab-stop:32.15pt;
	mso-level-number-position:left;
	margin-left:32.15pt;
	text-indent:-18.0pt;}
@list l4
	{mso-list-id:-128;
	mso-list-type:simple;
	mso-list-template-ids:-1398110164;}
@list l4:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:74.6pt;
	mso-level-number-position:left;
	margin-left:74.6pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l5
	{mso-list-id:-127;
	mso-list-type:simple;
	mso-list-template-ids:-1102161684;}
@list l5:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:60.45pt;
	mso-level-number-position:left;
	margin-left:60.45pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l6
	{mso-list-id:-126;
	mso-list-type:simple;
	mso-list-template-ids:-1161672330;}
@list l6:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:46.3pt;
	mso-level-number-position:left;
	margin-left:46.3pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l7
	{mso-list-id:-125;
	mso-list-type:simple;
	mso-list-template-ids:-1117109538;}
@list l7:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:32.15pt;
	mso-level-number-position:left;
	margin-left:32.15pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l8
	{mso-list-id:-120;
	mso-list-type:simple;
	mso-list-template-ids:-2063312820;}
@list l8:level1
	{mso-level-tab-stop:18.0pt;
	mso-level-number-position:left;
	margin-left:18.0pt;
	text-indent:-18.0pt;}
@list l9
	{mso-list-id:-119;
	mso-list-type:simple;
	mso-list-template-ids:-922086632;}
@list l9:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:18.0pt;
	mso-level-number-position:left;
	margin-left:18.0pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]-->
</head>

<body lang=EN-US link=blue vlink=purple style='tab-interval:36.0pt'>

<div class=Section1>

<h1 align=center style='text-align:center'><span lang=EN-GB>Static - A Force for
Good and Evil</span></h1>

<h3><span lang=EN-GB>Introduction</span></h3>

<p class=MsoNormal><span lang=EN-GB>I’ve noticed a trend among C# programmers
which is to avoid the use of the “static” keyword. It seems I’m not the only
one who’s noticed this either [1]. It’s not inherently limited to C#
programmers as C++ can be written in a similar manner, but the terminology bias
(functions vs. methods) and its clearer multi-paradigm stance means it’s probably
less susceptible. </span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>There is a perception that “static” things
– data and methods – are bad. In the wrong hands that can be true, but by
throwing the proverbial baby out with the bathwater we have closed the door on
embracing some of the goodness that functional-style programming brings.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>This article attempts to dispel the myths
by illustrating <i style='mso-bidi-font-style:normal'>which</i> uses of
“static” are bad and which are actually beneficial.</span></p>

<h3><span lang=EN-GB>Shared Mutable State</span></h3>

<p class=MsoNormal><span lang=EN-GB>My guess is that the static keyword has got
a bad rap because of past transgressions caused by functions that were designed
decades ago in a time when re-entrancy and multi-threading were something only
specialist programmers had to worry about. Yes </span><code><span lang=EN-GB
style='font-size:10.0pt'>strtok()</span></code><span lang=EN-GB> I’m looking at
you.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>This old C function which is used to
tokenise a string has some serious side-effects. Behind the scenes it keeps
track of the string being tokenised (which it also modifies) so that you can
keep calling it without supplying the original input string when fetching the
next token:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>char input[]
= &quot;unit test</span></code><span lang=EN-GB> </span><code><span lang=EN-GB
style='font-size:10.0pt'>&quot;;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>char
separators[] = &quot; &quot;;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>assert(strcmp(strtok(input,
separators), &quot;unit&quot;) == 0);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>assert(strcmp(strtok(NULL,
separators), &quot;test&quot;) == 0);<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>In a single-threaded environment you have
to be careful not to “nest” use of it (e.g. tokenise a token), and in a
multi-threaded environment this kind of behaviour is a disaster waiting to
happen. Fortunately many C implementations managed to avoid ruining a
programmer’s day due to spurious errors by utilising thread-local storage, but
this was a courtesy and not standards-defined behaviour.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>The anti-pattern, for want of a better term,
which can lead to this kind of sorry state of affairs, is to take a simple
function that only depends on its inputs and then find you need to add new
behaviour without changing its interface. In a waterfall-esque development
process the new behaviour could be the need to cache results, and the inability
to change the interface might come from discovering this very late during The Testing
Phase. Of course adding a cache and then accidentally making it non-thread-safe
is only going to exacerbate your woes at this point of the cycle. More likely
it doesn’t need to be thread-safe <i style='mso-bidi-font-style:normal'>initially</i>
but does later; only no one notices it’s not. The C# example below shows how
easy it can be to naively add a cache to an existing class:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public
static class ThingyProcessor<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public static int CalculateThing(int input)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>int output;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>if (Cache.TryGetValue(input, out
output))<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>            </span>return output;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>// Long calculation...<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>Cache.Add(input, output);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>return output;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>// Non-thread-safe collection<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private static Dictionary&lt;int, int&gt;
Cache =<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>                   </span>new Dictionary&lt;int,
int&gt;();<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Sharing mutable state via global variables
(</span><code><span lang=EN-GB style='font-size:10.0pt'>public static</span></code><span
lang=EN-GB> properties) is definitely a very bad smell and has been for many
years, but also sharing it implicitly across threads can be dangerous too. It’s
not just a matter of ensuring our own types are safe, it’s the whole object
graph, so any 3<sup>rd</sup> party collection types have to be checked too.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Although I’ve focused on complex types
above, it should be noted that primitive values are not immune from this
problem either. If anything they are likely to “appear to work” more than a
complex type due to their small footprint. Use of </span><code><span
lang=EN-GB style='font-size:10.0pt'>volatile</span></code><span lang=EN-GB> and
the various </span><code><span lang=EN-GB style='font-size:10.0pt'>Interlocked</span></code><span
lang=EN-GB> helper methods are required to keep them behaving properly.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Sometimes sharing mutable state is a
necessary evil but there should be precious few times when we need to enter
those murky waters. If possible we should look to change the interface or find
some other design to make the problem disappear altogether and keep the code
simple.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Before moving on let’s just go back to the
procedural world of C to look at how we might tackle this problematic function.
Putting aside for the moment the fact that </span><code><span lang=EN-GB
style='font-size:10.0pt'>strtok()</span></code><span lang=EN-GB> is a published
function specified by a standards process, we could avoid its state problem by
changing the interface to allow the state to passed back in by the caller. Also
we’d tackle the mutation of the input string to restrict the side-effects to
just the state object.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>typedef
struct strtok<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>const char* string;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>const char* separators;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>const char* tokenBegin;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>const char* tokenEnd;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}
strtok_state_t;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>const char*
input = &quot;unit test</span></code><span lang=EN-GB> </span><code><span
lang=EN-GB style='font-size:10.0pt'>&quot;;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>const char*
separators = &quot; &quot;;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>strtok_state_t
state;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>strtok(input,
separators, &amp;state);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>assert(strncmp(state.tokenBegin,
&quot;unit&quot;, state.tokenEnd - state.tokenBegin) == 0);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>strtok(NULL,
NULL, &amp;state);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>assert(strncmp(state.tokenBegin,
&quot;test&quot;, state.tokenEnd - state.tokenBegin) == 0);<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>There is still more that could be done to
improve matters, such as using two separate functions (e.g. </span><code><span
lang=EN-GB style='font-size:10.0pt'>firsttok()</span></code><span lang=EN-GB>/</span><code><span
lang=EN-GB style='font-size:10.0pt'>nexttok()</span></code><span lang=EN-GB>).
But this is C and combining state and functions into a more cohesive package is
exactly what object-orientation allows us to do more cleanly in languages like
C++ and C#. Hence in OO you might choose to present a </span><code><span
lang=EN-GB style='font-size:10.0pt'>strtok</span></code><span lang=EN-GB>–style
class in C# like this:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public class
StringTokeniser<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public StringTokeniser(string input, string
separators)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>// Remember inputs<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public string NextToken()<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>// Find next separator or the string
end by<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>      </span><span
style='mso-spacerun:yes'>  </span>// searching onwards from the last
‘position’.<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private readonly string _input;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private readonly string _separators;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private int _position;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<h3><span lang=EN-GB>Shared Immutable State</span></h3>

<p class=MsoNormal><span lang=EN-GB>When talking about the pitfalls of “shared
state” it’s important to qualify what sort of state you’re talking about. As we
just discussed, shared <i style='mso-bidi-font-style:normal'>mutable</i> state
can be dangerous when done badly. In contrast shared <i style='mso-bidi-font-style:
normal'>immutable</i> state is much safer; at least once the potentially tricky
initialisation phase is complete. Once we have a read-only data structure it
can be used concurrently without the need for any kind of locking. Even if it
can be referenced globally, which may still be another smell; it cannot be
changed behind our backs.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>For example, imagine you’re writing a
simple XML parser in C#. To handle the translation of entity references, such
as “&amp;amp;” to their equivalents you might decide to use a lookup table.
This table will likely be immutable and so it requires no additional locking in
the event that two threads attempt to parse separate XML documents
concurrently.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public class
XmlParser<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private static string DecodeEntity(string
entity)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>string output;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>if (EntityTable.TryGetValue(entity, out
output))<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>            </span>return output;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>return entity;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private static Dictionary&lt;string,
string&gt; EntityTable =<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>                   </span>new Dictionary&lt;string,
string&gt;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>{ &quot;&amp;amp;&quot;, &quot;&amp;&quot;
},<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>{ &quot;&amp;gt;&quot;,<span
style='mso-spacerun:yes'>  </span>&quot;&gt;&quot; },<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>{ &quot;&amp;lt;&quot;,<span
style='mso-spacerun:yes'>  </span>&quot;&lt;&quot; },<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>};<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>The initialisation issue is handled for us by
the C# language which guarantees that type constructors are thread-safe. That
said we need to be especially careful inside a type constructor because if it
throws things start going horribly wrong as the type can’t be loaded.</span></p>

<h3><span lang=EN-GB>Static Classes</span></h3>

<p class=MsoNormal><span lang=EN-GB>C#, unlike C++, does not allow methods to
exist outside of classes (often called free functions in C++). Consequently you
are forced into defining a class even when all you want to write is a simple
function. I suspect this has an undesirable side-effect on C# programmers
because I’ve seen them create classes that hold no state, or only hold
compile-time immutable state (i.e. constants), e.g.:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public class
ConfigurationSettings<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public string DatabaseName { get { return &quot;.
. . &quot;; } }<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>It’s not always as obvious as this and it
might be returned as a property of another class. These extra levels of
indirection make it harder for a static code analysis tool to spot it and
suggest a refactoring.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public class
Configuration<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public ConfigurationSettings Settings { get
{ return _settings; }}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private readonly ConfigurationSettings _settings
=<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>                     </span>new
ConfigurationSettings();<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>In a managed environment like C#, classes
such as the </span><code><span lang=EN-GB style='font-size:10.0pt'>ConfigurationSettings</span></code><span
lang=EN-GB> class above are quite literally garbage – the objects just get created
and then destroyed again and their behaviour can be determined entirely at
compile-time. As with free functions, constants in C# also need to be defined
as part of a class too:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public <b
style='mso-bidi-font-weight:normal'>static</b> class ConfigurationSettings<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public const string DatabaseName = &quot;.
. . &quot;;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>The C# answer to classes which shouldn’t be
instantiated is to declare them “static”. In essence the class is now acting as
merely a namespace, albeit one that you can’t elide with a “</span><code><span
lang=EN-GB style='font-size:10.0pt'>using</span></code><span lang=EN-GB>”
declaration at the top.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>The canonical example in C# for a static
class of “pure” functions (deterministic functions that only depend on their
inputs and have no side-effects) is probably the </span><code><span lang=EN-GB
style='font-size:10.0pt'>Math</span></code><span lang=EN-GB> class which plays
hosts to fundamentals like </span><code><span lang=EN-GB style='font-size:10.0pt'>Abs()</span></code><span
lang=EN-GB>and </span><code><span lang=EN-GB style='font-size:10.0pt'>Min()</span></code><span
lang=EN-GB>.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public
static class Math<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public static int Abs (int value)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>return (value &lt; 0) ? –value : value;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<h3><span lang=EN-GB>Static Functions</span></h3>

<p class=MsoNormal><span lang=EN-GB>Right back at the beginning I suggested one
reason why there might be a fear of static functions is because of where their implementation
could end up. I’d also suggest that programmers find it easier to pass
parameters to functions by making them <i style='mso-bidi-font-style:normal'>implicit</i>,
i.e. through class members accessible via “</span><code><span lang=EN-GB
style='font-size:10.0pt'>this</span></code><span lang=EN-GB>”.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Back in the 1980s Meilir Page-<st1:PersonName
w:st="on">Jo</st1:PersonName>nes wrote a book called The Practical Guide to
Structured System Design. He goes into detail about the various types of
coupling we might see in code, with each category being viewed as a less
desirable form from a maintenance perspective. Whilst the most serious forms of
coupling should be avoided, Page-<st1:PersonName w:st="on">Jo</st1:PersonName>nes
suggests that the weaker forms can be used effectively in the right hands, but
also have the <i style='mso-bidi-font-style:normal'>potential</i> to cause
grief in the wrong ones.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>At the farthest end of the spectrum we have
Content Coupling which is of little concern in today’s languages. Back in the
days of assembler programming you could jump from the middle of one “function”
right into the middle of another, meaning you couldn’t ever be sure where you’d
come from. Next up is Common Coupling, i.e. global variables. As the name
implies they have the ability to affect any and every part of the code-base in
unanticipated ways.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Then we come to Control Coupling. This is
where one function passes some kind of flag or signal to tell another how to
behave. Depending on the direction of the signal either a child is telling its
parent how to behave or the parent might know too much about the child’s
implementation, either way it’s a symptom of low cohesion.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Moving onwards we come to Stamp Coupling.
This oddly named formed of coupling is about passing excessive input to
functions that don’t need it. For example, if you had a function that formatted
a customer’s full name from their first and last names, you should consider only
passing those two arguments, not an entire Customer record. By passing the
entire type you make the function (appear to be) dependent on attributes it
doesn’t use.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Finally we reach Data Coupling which is
analogous to a “pure” function. What Page-<st1:PersonName w:st="on">Jo</st1:PersonName>nes
tells us is that the easiest code to reason about is this style of function
which, as mentioned earlier, has a deterministic output solely based on its direct
inputs with no side-effects. In essence, given that <i style='mso-bidi-font-style:
normal'>some</i> form of coupling is a necessity to do anything useful, then
Data Coupling is the most preferable.</span></p>

<h3><span lang=EN-GB>Member Coupling</span></h3>

<p class=MsoNormal><span lang=EN-GB>His book was published in a time before
Object-Orientated Programming was A Big Thing. He is also concerned more with
inter-module coupling rather than intra-module coupling, such as between
methods of the same class. As the size of a class grows it becomes more common
to rely further and further on data being passed between methods via its own
state, i.e. its members. I believe there is a form of Stamp Coupling going on
here as any method might use its input arguments plus any aspect of the object’s
current state or per-class state, and so it is impossible to know what that is
without looking at the implementation of an instance method. And that is what
coupling is all about – being able to reason about the knock-on effects of a
change to other parts of the code.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>The over reliance of implied state makes it
harder to refactor code later because pulling that state out to another data
structure may require lots of unexpected fixing up of other methods. I’ve found
that taking Page-<st1:PersonName w:st="on">Jo</st1:PersonName>nes’s advice to favour
Data Coupling right into the heart of classes has made code easier to read
because simple methods start looking like simple black boxes again.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>As a simple example consider the class-based
OO version of the </span><code><span lang=EN-GB style='font-size:10.0pt'>strtok()</span></code><span
lang=EN-GB> function I mentioned earlier. In the implementation, when it comes
to finding the next token we could rely solely on the implied state held in the
member variables and code it up as one method:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public class
StringTokeniser<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>. . .<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public string NextToken()<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>if (_position == _input.Length)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>            </span>return null;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>var start = _position + 1;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>_position = _input.IndexOf(_separators,
start);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>if (_position == -1)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>            </span>_position = _input.Length; <o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>return _input.Substring(start, _position
- start);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private readonly string _input;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private readonly string _separators;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private int _position = -1;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>One alterative would be to hand-off the
finding off the end of the token to a separate little method that is only
dependent on its inputs:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public class
StringTokeniser<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>. . .<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public string NextToken()<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>if (_position == _input.Length)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>            </span>return null;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>var start = _position + 1;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>var end = FindTokenEnd(_input,
_separators, start);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>var token = _input.Substring(start, end
- start);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>_position = end;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>return token;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public static int FindTokenEnd(string
input, string separators,<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>                                   </span>int start)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>var end = input.IndexOf(separators, start);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>if (end == -1)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>            </span>return input.Length; <o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>return end;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private string _input;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private string _separators;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private int _position = -1;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Although the first implementation of </span><code><span
lang=EN-GB style='font-size:10.0pt'>NextToken()</span></code><span lang=EN-GB> is
quite small there is perhaps a temptation to put a comment above the bit of
code that finds the end of the token because it’s not immediately apparent due
to the overloaded use of the </span><code><span lang=EN-GB style='font-size:
10.0pt'>_position</span></code><span lang=EN-GB> member (initial start of the next
token and then the end of next token). Whenever I find myself wanting to write
a comment I consider that to be a sign I should use the Extract Method or Introduce
Explaining Variable [2] refactorings instead.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>There might be a knee-jerk reaction that
splitting code up into so many simple methods would create a big hit on performance.
It is possible, but then we all know that premature optimisation is a dangerous
pastime. The <st1:stockticker w:st="on">JIT</st1:stockticker> compiler in .Net
and modern C++ compilers can do a pretty good job these days of inlining
methods so you’ll probably not notice it in the vast majority of your code.</span></p>

<h3><span lang=EN-GB>Exception Safety</span></h3>

<p class=MsoNormal><span lang=EN-GB>Whilst it’s highly unlikely that any client
code would attempt to recover directly from an OutOfMemory exception thrown
from our </span><code><span lang=EN-GB style='font-size:10.0pt'>StringTokeniser</span></code><span
lang=EN-GB> class, it is a library function and they often get used in
mysterious ways. Writing exception safe code is hard, especially when it’s so
easy to mutate state at an unsafe moment.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>A common example I’ve seen of this is when
two-phase construction is used and the second phase throws an exception,
leaving a member mutated by accident:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public class
ProcessManager<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>. . .<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public void Execute<st1:PersonName w:st="on">Jo</st1:PersonName>b(<st1:PersonName
w:st="on">Jo</st1:PersonName>b job)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>if (_process == null)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>            </span>_process = new Process();<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>            </span>_process.Start(_applicationName);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>. . .<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>_process.Execute(job);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>. . .<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private readonly string _applicationName;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private Process _process;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Here, if </span><code><span lang=EN-GB
style='font-size:10.0pt'>Execute<st1:PersonName w:st="on">Jo</st1:PersonName>b()</span></code><span
lang=EN-GB> throws when the </span><code><span lang=EN-GB style='font-size:
10.0pt'>Start()</span></code><span lang=EN-GB> method is called the </span><code><span
lang=EN-GB style='font-size:10.0pt'>_process</span></code><span lang=EN-GB>
member will be left pointing to a partially initialised object. When the second
call to </span><code><span lang=EN-GB style='font-size:10.0pt'>Execute<st1:PersonName
w:st="on">Jo</st1:PersonName>b()</span></code><span lang=EN-GB> comes in it
will assume the </span><code><span lang=EN-GB style='font-size:10.0pt'>_process</span></code><span
lang=EN-GB> member is fully initialised and will try and to use it.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>The general pattern for writing exception
safe code is to perform all code that might throw off to the side and then
commit the changes locally with non-throwing operations. In this example we could
have written it like this:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public void Execute<st1:PersonName w:st="on">Jo</st1:PersonName>b(<st1:PersonName
w:st="on">Jo</st1:PersonName>b job)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>if (_process == null)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>            </span>var process = new Process();<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>            </span>process.Start(_applicationName);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>            </span>_process = process;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>. . .<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>_process.Execute(job);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Internal factory methods are a good fit for
being static because object creation and initialisation is often full of code
likely to throw that you might want to keep at arms length until you know
you’re dealing with fully constructed objects. By factoring the creation out
into a static method you also convey to both the compiler and the reader that
they shouldn’t be messing with any of </span><code><span lang=EN-GB
style='font-size:10.0pt'>this</span></code><span lang=EN-GB> object’s state at
that point of its lifecycle, e.g.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public class
ProcessManager<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public void Execute<st1:PersonName w:st="on">Jo</st1:PersonName>b(<st1:PersonName
w:st="on">Jo</st1:PersonName>b job)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>if (_process == null)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>            </span>_process = CreateProcess(_applicationName);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>. . .<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>       </span><span
style='mso-spacerun:yes'> </span>_process.Execute(job);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private static Process CreateProcess(string
applicationName)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>var process = new Process();<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>process.Start(applicationName);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>return process;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>. . .<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>private Process _process;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<h3><span lang=EN-GB>Extension Methods</span></h3>

<p class=MsoNormal><span lang=EN-GB>Whilst C# might not support “free functions”,
it does have Extension Methods and these often embody the practice of writing
small independent methods. They are members of a static class and are themselves
declared static, despite the fact that they appear to be called as instance
methods. If you ever wished that the C# String class had an instance method
that could tell you whether a string was empty or just contained white-space,
you can make it happen yourself:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public
static class StringExtensions<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public static bool IsBlank(this string
value)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>return (value.Trim().Length == 0);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public
static class Program<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public static int <st1:place w:st="on">Main</st1:place>(string[]
args)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>. . .<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span><span style='mso-spacerun:yes'>    </span>string
connectionString = configuration.ConnectionString;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span><span style='mso-spacerun:yes'>    </span>if
(!connectionString.IsBlank())<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>            </span>connection =
OpenConnection(connectionString);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>. . .<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>This is often how I find extension methods
come about. Initially they start as a simple static method in a class that
looks suspiciously as though the first argument really wants to be “</span><code><span
lang=EN-GB style='font-size:10.0pt'>this</span></code><span lang=EN-GB>”. Once
reuse rears its head it’s a simple step to factor it out into a common
extension method. Alternatively it could be pulled out as a formal extension
method, but left defined inside a private static class of the current consumer to
avoid publishing it formally as that comes with the possible burden of needing
to write separate unit tests.</span></p>

<h3><span lang=EN-GB>Building Classes from Static Methods</span></h3>

<p class=MsoNormal><span lang=EN-GB>The Object-Orientated paradigm is good for
creating types that represent things, but when it comes to algorithms and
processes it can start to get ugly. Take the process of parsing a string of XML
into a <st1:stockticker w:st="on">DOM</st1:stockticker> for example. Whilst the
input string can be an object, and the output is a tree of objects, the algorithm
used to process the characters in the string and create the tree of objects
feels much less object-like. It feels to me more like a function that
transforms one to the other. Yes, there will be some temporal state involved
during the processing, but by-and-large the decomposition of the problem has
more of a focus on functions.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>If I was using Test-Driven Development to
tackle a problem like this my initial tests would very likely start out with just
a simple function:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>[Test]<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public void
when_xml_is_empty_then_dom_is_empty()<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>const string emptyXml = &quot;&quot;;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>var document =
XmlParser.ParseDocument(emptyXml);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>Assert.That(document, Is.Not.Null);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>You can argue about whether it should be a
member of a class called </span><code><span lang=EN-GB style='font-size:10.0pt'>XmlDocument</span></code><span
lang=EN-GB>, or </span><code><span lang=EN-GB style='font-size:10.0pt'>XmlReader</span></code><span
lang=EN-GB>, etc. but either way I wouldn’t start out expecting to create a
class like this:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>[Test]<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public void
when_xml_is_empty_then_dom_is_empty()<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>const string emptyXml = &quot;&quot;;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>var parser = new XmlParser();<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>var document =
parser.ParseDocument(emptyXml);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>Assert.That(document, Is.Not.Null);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Anyone who uses FizzBuzz [3] or the Roman
Numerals kata in their interview process to separate the “wheat from the chaff”
will probably see this kind of thing. It’s not wrong, per-se, but it can lead
to the kind of “empty” classes described above.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>From a Design Pattern’s perspective what my
eventual function will become is akin to a façade over a bunch of other functions.
As the number of tests grow, so will the number of internal functions. Internal
refactoring will start to push some of those out into separate (internal) classes
which in turn will likely receive their own more focused unit tests. The
handling of XML entity references earlier was very simplistic, just a lookup
table, but as more scenarios are discovered so the complexity of that aspect of
the implementation will likely increase.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>The state required during parsing is
entirely transient from the perspective of the caller. It could be held inside
an instance of the </span><code><span lang=EN-GB style='font-size:10.0pt'>XmlParser</span></code><span
lang=EN-GB> class, where the public class gets a private constructor because it
just becomes an implementation detail of the static </span><code><span
lang=EN-GB style='font-size:10.0pt'>ParseDocument()</span></code><span
lang=EN-GB> method. But why even expose that, why not create an internal class,
say, </span><code><span lang=EN-GB style='font-size:10.0pt'>XmlParserImpl</span></code><span
lang=EN-GB> and treat </span><code><span lang=EN-GB style='font-size:10.0pt'>ParseDocument()</span></code><span
lang=EN-GB> as a sort of top-level factory method?</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>internal
class XmlParserImpl<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>. . .<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>public
static class XmlParser<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>public static Dom ParseDocument(string xml)<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>{<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>var parser = new XmlParserImpl(xml);<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>        </span>return parser.ParseDocument();<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'><span
style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>}<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>If the implementation class is internal then
the entire type is encapsulated and so we could hold the state as a Dumb Data Object
[4] and access it in our static methods via public fields (so long as we
promise never to expose it). Then again we could hold the state entirely on the
stack by passing it as parameters to recursion functions.</span></p>

<h3><span lang=EN-GB>Methods on Immutable Types</span></h3>

<p class=MsoNormal><st1:PersonName w:st="on"><span lang=EN-GB>Jo</span></st1:PersonName><span
lang=EN-GB>n Skeet raised a question at the Norfolk Developers Conference [5] about
how to make methods on immutable types more intention revealing. His canonical
example in C# involves the </span><code><span lang=EN-GB style='font-size:10.0pt'>DateTime</span></code><span
lang=EN-GB> class like this:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>DateTime
date = DateTime.Today;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>date.AddDays(1);<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>The method name </span><code><span
lang=EN-GB style='font-size:10.0pt'>AddDays</span></code><span lang=EN-GB> suggests
that it will add 1 day to </span><code><span lang=EN-GB style='font-size:10.0pt'>date</span></code><span
lang=EN-GB> and give us the date for tomorrow. Only it won’t. It will create a
new </span><code><span lang=EN-GB style='font-size:10.0pt'>DateTime</span></code><span
lang=EN-GB> value based on </span><code><span lang=EN-GB style='font-size:10.0pt'>date</span></code><span
lang=EN-GB> (with an offset) which will subsequently be thrown away by the
caller. It’s an easy mistake to make and one of the reasons why writing tests
is such a worthy pursuit. The example should have been:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>DateTime
date = DateTime.Today;<o:p></o:p></span></code></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>DateTime
tomorrow = date.AddDays(1);<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><st1:PersonName w:st="on"><span lang=EN-GB>Jo</span></st1:PersonName><span
lang=EN-GB>n went on to question whether there is a way to name methods to make
this pattern (returning a new value instead of mutating the existing one) more
revealing. He proposed this for the example above:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>DateTime
tomorrow = date.PlusDays(1);<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>It is an improvement, but I would posit
that it’s just too subtle a change in language to really make a difference.
Part of the problem is that mutability is the default position in C#; for
example the object initializer syntactic sugar relies on the class having
writable properties.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>My own stance is that once again we can
draw from the functional side and use static methods (aka functions) to more
clearly suggest that a new value will be created from an existing one and some
adjustment:-</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>DateTime
tomorrow = Date.AddDays(date, 1);<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>If you started making the same mistake
above with this style, would it be any more obvious?</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><code><span lang=EN-GB style='font-size:10.0pt'>Date.AddDays(date,
1);<o:p></o:p></span></code></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>At least this way you start by invoking a
static method and so that should tell you something extra that you don’t get by
invoking an instance method.</span></p>

<h3><span lang=EN-GB>Summary</span></h3>

<p class=MsoNormal><span lang=EN-GB>The “static” keyword is in need of a public
relations exercise in C# to try and overcome prejudices caused by
misunderstanding its role. C# might have started out with a heavy bias towards
the object-orientated paradigm but over the years its audience and the language
have tried to embrace a multi-paradigm world. This means a stronger focus on
immutability and the use of functions instead of objects and mutable state, at
least for those problems where it’s beneficial.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>The natural outcome of this is code that is
easier to reason about and inherently thread-safe. Whilst another language such
as F# might be a better tool for the job by removing some of the ceremony,
there is no reason why you cannot adopt some of their practices to improve a C#
codebase.</span></p>

<h3><span lang=EN-GB>Acknowledgements</span></h3>

<p class=MsoNormal><span lang=EN-GB>A debt of gratitude is owed to Ric Parkin
and <st1:PersonName w:st="on">Roger Orr</st1:PersonName> for helping me polish
this article.</span></p>

<h3><span lang=EN-GB>References</span></h3>

<p class=MsoNormal><span lang=EN-GB>[1] <a
href="https://twitter.com/codemonkey_uk/statuses/385518295958683649">https://twitter.com/codemonkey_uk/statuses/385518295958683649</a></span></p>

<p class=MsoNormal><span lang=EN-GB>[2] <a
href="http://martinfowler.com/books/refactoring.html">http://martinfowler.com/books/refactoring.html</a></span></p>

<p class=MsoNormal><span lang=EN-GB>[3] <a
href="http://c2.com/cgi/wiki?FizzBuzzTest">http://c2.com/cgi/wiki?FizzBuzzTest</a></span></p>

<p class=MsoNormal><span lang=EN-GB>[4] <a
href="http://c2.com/cgi/wiki?DumbDataObject">http://c2.com/cgi/wiki?DumbDataObject</a></span></p>

<p class=MsoNormal><span lang=EN-GB>[5] <a href="http://nordevcon.com/">http://nordevcon.com/</a></span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><st1:PersonName w:st="on"><span lang=EN-GB>Chris Oldwood</span></st1:PersonName></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-GB><span
style='mso-element:field-begin'></span><span
style='mso-spacerun:yes'> </span>SAVEDATE<span style='mso-spacerun:yes'> 
</span>\@ &quot;dd MMMM yyyy&quot;<span style='mso-spacerun:yes'>  </span>\*
MERGEFORMAT <span style='mso-element:field-separator'></span></span><![endif]--><span
lang=EN-GB><span style='mso-no-proof:yes'>10 March 2014</span></span><!--[if supportFields]><span
lang=EN-GB><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><u><span lang=EN-GB>Bio<o:p></o:p></span></u></p>

<p class=MsoNormal><span lang=EN-GB>Chris is a freelance developer who started
out as a bedroom coder in the 80’s writing assembler on 8-bit micros; these
days it’s C++ and C#. He also commentates on the Godmanchester duck race and
can be contacted via <a href="mailto:gort@cix.co.uk">gort@cix.co.uk</a> or
@chrisoldwood.</span></p>

</div>

</body>

</html>
