<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=Generator content="Microsoft Word 12 (filtered)">
<title>A Case of Mistaken Identity</title>
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Cambria;
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:10.0pt;
	margin-left:0cm;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
h1
	{mso-style-link:"Heading 1 Char";
	margin-top:24.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Cambria","serif";
	color:#21798E;}
h2
	{mso-style-link:"Heading 2 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:13.0pt;
	font-family:"Cambria","serif";
	color:#2DA2BF;}
h3
	{mso-style-link:"Heading 3 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Cambria","serif";
	color:#2DA2BF;}
h4
	{mso-style-link:"Heading 4 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Cambria","serif";
	color:#2DA2BF;
	font-style:italic;}
h5
	{mso-style-link:"Heading 5 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Cambria","serif";
	color:#16505E;
	font-weight:normal;}
h6
	{mso-style-link:"Heading 6 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Cambria","serif";
	color:#16505E;
	font-weight:normal;
	font-style:italic;}
p.MsoHeading7, li.MsoHeading7, div.MsoHeading7
	{mso-style-link:"Heading 7 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Cambria","serif";
	color:#404040;
	font-style:italic;}
p.MsoHeading8, li.MsoHeading8, div.MsoHeading8
	{mso-style-link:"Heading 8 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Cambria","serif";
	color:#2DA2BF;}
p.MsoHeading9, li.MsoHeading9, div.MsoHeading9
	{mso-style-link:"Heading 9 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Cambria","serif";
	color:#404040;
	font-style:italic;}
p.MsoCaption, li.MsoCaption, div.MsoCaption
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:10.0pt;
	margin-left:0cm;
	font-size:9.0pt;
	font-family:"Calibri","sans-serif";
	color:#2DA2BF;
	font-weight:bold;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{mso-style-link:"Title Char";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:15.0pt;
	margin-left:0cm;
	border:none;
	padding:0cm;
	font-size:26.0pt;
	font-family:"Cambria","serif";
	color:#343434;
	letter-spacing:.25pt;}
p.MsoTitleCxSpFirst, li.MsoTitleCxSpFirst, div.MsoTitleCxSpFirst
	{mso-style-link:"Title Char";
	margin:0cm;
	margin-bottom:.0001pt;
	border:none;
	padding:0cm;
	font-size:26.0pt;
	font-family:"Cambria","serif";
	color:#343434;
	letter-spacing:.25pt;}
p.MsoTitleCxSpMiddle, li.MsoTitleCxSpMiddle, div.MsoTitleCxSpMiddle
	{mso-style-link:"Title Char";
	margin:0cm;
	margin-bottom:.0001pt;
	border:none;
	padding:0cm;
	font-size:26.0pt;
	font-family:"Cambria","serif";
	color:#343434;
	letter-spacing:.25pt;}
p.MsoTitleCxSpLast, li.MsoTitleCxSpLast, div.MsoTitleCxSpLast
	{mso-style-link:"Title Char";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:15.0pt;
	margin-left:0cm;
	border:none;
	padding:0cm;
	font-size:26.0pt;
	font-family:"Cambria","serif";
	color:#343434;
	letter-spacing:.25pt;}
p.MsoSubtitle, li.MsoSubtitle, div.MsoSubtitle
	{mso-style-link:"Subtitle Char";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:10.0pt;
	margin-left:0cm;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Cambria","serif";
	color:#2DA2BF;
	letter-spacing:.75pt;
	font-style:italic;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p.MsoNoSpacing, li.MsoNoSpacing, div.MsoNoSpacing
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:10.0pt;
	margin-left:36.0pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.0pt;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.0pt;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:10.0pt;
	margin-left:36.0pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoQuote, li.MsoQuote, div.MsoQuote
	{mso-style-link:"Quote Char";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:10.0pt;
	margin-left:0cm;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	color:black;
	font-style:italic;}
p.MsoIntenseQuote, li.MsoIntenseQuote, div.MsoIntenseQuote
	{mso-style-link:"Intense Quote Char";
	margin-top:10.0pt;
	margin-right:46.8pt;
	margin-bottom:14.0pt;
	margin-left:46.8pt;
	line-height:115%;
	border:none;
	padding:0cm;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	color:#2DA2BF;
	font-weight:bold;
	font-style:italic;}
span.MsoSubtleEmphasis
	{color:gray;
	font-style:italic;}
span.MsoIntenseEmphasis
	{color:#2DA2BF;
	font-weight:bold;
	font-style:italic;}
span.MsoSubtleReference
	{font-variant:small-caps;
	color:#DA1F28;
	text-decoration:underline;}
span.MsoIntenseReference
	{font-variant:small-caps;
	color:#DA1F28;
	letter-spacing:.25pt;
	font-weight:bold;
	text-decoration:underline;}
span.MsoBookTitle
	{font-variant:small-caps;
	letter-spacing:.25pt;
	font-weight:bold;}
p.MsoTocHeading, li.MsoTocHeading, div.MsoTocHeading
	{margin-top:24.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Cambria","serif";
	color:#21798E;
	font-weight:bold;}
span.TitleChar
	{mso-style-name:"Title Char";
	mso-style-link:Title;
	font-family:"Cambria","serif";
	color:#343434;
	letter-spacing:.25pt;}
span.Heading3Char
	{mso-style-name:"Heading 3 Char";
	mso-style-link:"Heading 3";
	font-family:"Cambria","serif";
	color:#2DA2BF;
	font-weight:bold;}
span.Heading1Char
	{mso-style-name:"Heading 1 Char";
	mso-style-link:"Heading 1";
	font-family:"Cambria","serif";
	color:#21798E;
	font-weight:bold;}
span.Heading2Char
	{mso-style-name:"Heading 2 Char";
	mso-style-link:"Heading 2";
	font-family:"Cambria","serif";
	color:#2DA2BF;
	font-weight:bold;}
span.Heading4Char
	{mso-style-name:"Heading 4 Char";
	mso-style-link:"Heading 4";
	font-family:"Cambria","serif";
	color:#2DA2BF;
	font-weight:bold;
	font-style:italic;}
span.Heading5Char
	{mso-style-name:"Heading 5 Char";
	mso-style-link:"Heading 5";
	font-family:"Cambria","serif";
	color:#16505E;}
span.Heading6Char
	{mso-style-name:"Heading 6 Char";
	mso-style-link:"Heading 6";
	font-family:"Cambria","serif";
	color:#16505E;
	font-style:italic;}
span.Heading7Char
	{mso-style-name:"Heading 7 Char";
	mso-style-link:"Heading 7";
	font-family:"Cambria","serif";
	color:#404040;
	font-style:italic;}
span.Heading8Char
	{mso-style-name:"Heading 8 Char";
	mso-style-link:"Heading 8";
	font-family:"Cambria","serif";
	color:#2DA2BF;}
span.Heading9Char
	{mso-style-name:"Heading 9 Char";
	mso-style-link:"Heading 9";
	font-family:"Cambria","serif";
	color:#404040;
	font-style:italic;}
span.SubtitleChar
	{mso-style-name:"Subtitle Char";
	mso-style-link:Subtitle;
	font-family:"Cambria","serif";
	color:#2DA2BF;
	letter-spacing:.75pt;
	font-style:italic;}
span.QuoteChar
	{mso-style-name:"Quote Char";
	mso-style-link:Quote;
	color:black;
	font-style:italic;}
span.IntenseQuoteChar
	{mso-style-name:"Intense Quote Char";
	mso-style-link:"Intense Quote";
	color:#2DA2BF;
	font-weight:bold;
	font-style:italic;}
@page WordSection1
	{size:595.3pt 841.9pt;
	margin:72.0pt 72.0pt 72.0pt 72.0pt;}
div.WordSection1
	{page:WordSection1;
	width: 600px;
	margin-left: auto;
	margin-right: auto;}
-->
</style>

</head>

<body lang=EN-GB link=blue vlink=purple>

<div class=WordSection1>

<div style='border:none;border-bottom:solid #2DA2BF 1.0pt;padding:0cm 0cm 4.0pt 0cm'>

<p class=MsoTitle>A Case of Mistaken Identity</p>

</div>

<p class=MsoNormal>I recently unearthed a bug in some C# code where,
superficially, the cause appeared to be a single character, but on closer
inspection it was not entirely clear what the author’s intentions really were.
This was down to a number of factors, not least the lack of tests, but it got
me thinking about what those intentions might have been and what other practices
could have prevented it in the first place.</p>

<h1>The Bug</h1>

<p class=MsoNormal>The line of failing code was a simple conditional statement
that would induce some error handling logic when true. My suspicion there was a
bug were immediately aroused when the tool reported an error code of “none”. If
you’ve ever seen a Windows application report an error with the text “<span
style='font-family:"Courier New"'>The operation completed successfully</span>”
then you’ll know what I’m talking about. This was the statement:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>if (result != Error.None)<br>
{<br>
  // report error<br>
}</span></p>

<p class=MsoNormal>Naturally I switched to the <span style='font-family:"Courier New"'>Error</span>
class definition to see what it looked like. It was a pretty sparse class with <span
style='font-family:"Courier New"'>None</span> defined as a simple static
property alongside a couple of other static methods:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>public enum ErrorCode<br>
{<br>
  None,<br>
  NotFound,<br>
  AccessDenied,<br>
}<br>
<br>
public class Error<br>
{<br>
  public ErrorCode Code { get; }<br>
  public string Message { get; }<br>
<br>
  public Error(ErrorCode code, string message = &quot;&quot;)<br>
  {<br>
    Code = code;<br>
    Message = message;<br>
  }<br>
<br>
  public static Error None =&gt; new Error(ErrorCode.None);<br>
  public static Error NotFound(string message) =&gt; new
Error(ErrorCode.NotFound, message);<br>
  public static Error AccessDenied(string message) =&gt; new
Error(ErrorCode.AccessDenied, message);<br>
}</span></p>

<p class=MsoNormal>Initially I didn’t spot the mistake but I realised from the
way the conditional statement was behaving that it had to be something to do
with the object’s identity. The lack of an <span style='font-family:"Courier New"'>Equals()</span>
implementation meant it would be using reference based equality, not value
semantics, which suggested that the two objects were not exactly the same
object in memory.</p>

<p class=MsoNormal>My gut instinct was that the return site was creating the
object directly instead of using the static property and so I was surprised when
it was correct, like so:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>return Error.None;</span></p>

<p class=MsoNormal>Scratching my head I went back to the <span
style='font-family:"Courier New"'>Error</span> class, studied it more closely,
and then I noticed the subtle mistake – the extra “<span style='font-family:
"Courier New"'>&gt;</span>” in the property definition. This static property,
instead of creating a <i>single</i> instance of the value when the class type
is initialised, creates one <i>every</i> time it’s invoked! This explains why
the reference based comparison fails – it will <i>never</i> be the same object
in memory.</p>

<h1>New Syntax, New Bugs</h1>

<p class=MsoNormal>Prior to C# 6 the syntax for defining static properties was
somewhat more verbose. For example if you wanted to declare a static property
backed by a value, you would write:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>public static Error None = new Error(ErrorCode.None);</span></p>

<p class=MsoNormal>This creates a writable property. If you wanted a read-only
static property you could use a custom getter like this:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>public static Error None { get { return new
Error(ErrorCode.None); } }</span></p>

<p class=MsoNormal>With C# 6 however came a simplified syntax especially for
read-only properties which either have automatic backing storage or are
implemented by an expression body. Hence the former now becomes:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>public static Error None { get; } = new Error(ErrorCode.None);</span></p>

<p class=MsoNormal>…and the latter can be turned into just this:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>public static Error None =&gt; new Error(ErrorCode.None);</span></p>

<p class=MsoNormal>These two forms together don’t look so similar but if you compare
the very first and last side-by-side you’ll see they are incredibly similar:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>public static Error None = new Error(ErrorCode.None);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>public static Error None =&gt; new Error(ErrorCode.None);</span></p>

<p class=MsoNormal>The only difference between these two statements in fact is
a single character, the “<span style='font-family:"Courier New"'>&gt;</span>”, which
turns the assignment operator into the lambda arrow operator. Semantically,
this changes a writable static property which has a value created at class
initialisation, into a read-only static property backed by an expression body that
returns a new value every time it’s invoked. As you can see these two are
functionally very similar but as we’ve just seen from the bug subtly different
depending on the value semantics of the enclosing type.</p>

<h1>The Fix, or Is It?</h1>

<p class=MsoNormal>The “obvious” minimal fix from the calling code’s
perspective is to remove the extraneous “<span style='font-family:"Courier New"'>&gt;</span>”
character from the property definition and ensure that there is only one
instance of <span style='font-family:"Courier New"'>None</span> ever retrieved
from it. With only a single instance in play a reference based equality
comparison will always succeed. In fact we can go one better and avoid the
backdoor that allows <span style='font-family:"Courier New"'>None</span> to be
replaced by using the <span style='font-family:"Courier New"'>readonly</span>
keyword to ensure that it cannot ever be changed by a client or the class
itself (outside the type constructor):</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>public readonly static Error None = new Error(ErrorCode.None);</span></p>

<p class=MsoNormal>That fixes the actual bug, but it still leaves a number of
questions. For example, was the reference based comparison really the
intention, and if so, how hard did the author try to avoid letting a caller
create a duplicate object <i>like</i> <span style='font-family:"Courier New"'>None</span>?
As you can see the <span style='font-family:"Courier New"'>Error</span> type’s constructor
was marked <span style='font-family:"Courier New"'>public</span> and so the consuming
code could have just as easily written this instead:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>return new Error(ErrorCode.None);</span></p>

<p class=MsoNormal>Once again the reference based comparison would have failed
because the returned object was never the same as the single instance held by
the static property.</p>

<p class=MsoNormal>Another observation is that the underlying error value (from
the <span style='font-family:"Courier New"'>ErrorCode</span> enumeration) is accessible
via a public read-only property:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>public ErrorCode Code { get; }</span></p>

<p class=MsoNormal>Therefore it’s entirely possible the author may have
intended for the conditional statement to be written like this instead:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>if (result.Code != ErrorCode.None)</span></p>

<p class=MsoNormal>Now we’re doing a comparison of two values from an
enumerated type and therefore we get a value based comparison instead which
will always succeed irrespective of whether <span style='font-family:"Courier New"'>result</span>
holds the <span style='font-family:"Courier New"'>None</span> singleton or not.
The big similarity in the name of the <span style='font-family:"Courier New"'>Error</span>
class and the name of the underlying <span style='font-family:"Courier New"'>ErrorCode</span>
enumeration could easily explain how one could have been written instead of the
other.</p>

<h1>Factory Methods</h1>

<p class=MsoNormal>Perhaps we are on the right lines with assuming that
reference based equality was desirable if we bring in an observation around the
two factory methods, which also use the new expression body syntax to make them
light on ceremony:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>  public static Error NotFound(. . .) =&gt; new Error(. . .);<br>
  public static Error AccessDenied(. . .) =&gt; new Error(. . .);</span></p>

<p class=MsoNormal>Maybe there is one other mistake and the <span
style='font-family:"Courier New"'>Error</span> constructor was never intended
to be made <span style='font-family:"Courier New"'>public</span> in the first
place. Perhaps it should have been marked <span style='font-family:"Courier New"'>private</span>
so that clients are forced to create an instance of the object thorough one of
the factory methods, or use the <span style='font-family:"Courier New"'>None</span>
value. Hence in the scenario of an error the returning code would therefore
write something this:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>return Error.NotFound($&quot;{path} not found&quot;);</span></p>

<p class=MsoNormal>Given the potential for a free format message it’s highly
unlikely the calling code would ever attempt to perform an equality comparison
on an instance of the <span style='font-family:"Courier New"'>Error</span>
type, except for a comparison against <span style='font-family:"Courier New"'>None</span>.
Consequently these two little fixes (one to the <span style='font-family:"Courier New"'>None</span>
property and the other to the constructor) might be enough for us to declare
the problem “properly fixed”.</p>

<h1>Value Semantics</h1>

<p class=MsoNormal>Up until this point I have worked on the assumption that the
author really did want the comparison using the “<span style='font-family:"Courier New"'>==</span>”
operator to work correctly and so we’ve found ways to make that happen for the
scenario that initially brought it to our attention. However these little
tweaks feel somewhat akin to moving the deckchairs around on the Titanic as
we’re not really fixing the type itself to perform all comparisons correctly.</p>

<p class=MsoNormal>The <span style='font-family:"Courier New"'>Error</span> type
is composed of two values which should both take part in a proper value based
comparison. As anyone who attended Steve Love and Roger Orr’s ACCU talk a few
years back about implementing equality comparisons will remember, these are
non-trivial things to implement in languages like C# and Java. There is a lot
of boilerplate code to add (and a <span style='font-family:"Courier New"'>GetHashCode()</span>
implementation for completeness) which many IDEs will happy produce for you to
save typing and ensure all the options are correctly covered, but the meat is
essentially just a comparison of the two embedded properties:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>public static bool operator==(Error lhs, Error rhs)<br>
{<br>
  return (lhs.Code == rhs.Code) &amp;&amp; (lhs.Message == rhs.Message);<br>
}</span></p>

<p class=MsoNormal>Now when we invoke our original failing comparison against <span
style='font-family:"Courier New"'>None</span> in the client’s error handling
code we will get a fuller comparison of the object’s embedded members instead
of just their references. Additionally because we’re performing a deeper
comparison we don’t <i>have</i> to change the <span style='font-family:"Courier New"'>None</span>
definition because any instance of <span style='font-family:"Courier New"'>None</span>
will now be equivalent to any other (although creating one every time could be considered
wasteful).</p>

<p class=MsoNormal>This feels like a more complete fix for our equality bug but
I’m still left wondering if it’s the right thing to do. Making a type into a
value type just because I want an equality comparison to do the right thing in
one scenario does not feel overly compelling. When pondering whether to make
something a value type or not I have an acid test that asks if I’d ever likely
use it as a key in a dictionary or put it into some kind of set. </p>

<p class=MsoNormal>Once again the free-text error message property suggests to
me that this isn’t really a classic value type. Yes, the comparison with <span
style='font-family:"Courier New"'>None</span> feels more succinct but in any
other situation you are likely to ignore the message part and only consider the
<span style='font-family:"Courier New"'>ErrorCode</span>. This implies to me
that the message isn’t really part of the object’s identity per-se but is being
bundled along with the code for convenience (as C# does not support multiple
return values). This leads me back to believing the real mistake is in the
conditional statement in the caller and should have been this one which we
covered earlier that compares the <span style='font-family:"Courier New"'>Code</span>
property directly:</p>

<p class=MsoNormal><span style='font-size:10.0pt;line-height:115%;font-family:
"Courier New"'>if (result.Code != ErrorCode.None)</span></p>

<h1>Software Archaeology</h1>

<p class=MsoNormal>At this point I’ve pretty much exhausted my analysis based
on the current state of the callers and implementation and so I decided to do a
spot of software archaeology [2] and trawl the version control logs to see what
else it could tell me about the history of this code.</p>

<p class=MsoNormal>It turns out it has very little to say. The <span
style='font-family:"Courier New"'>Error</span> class only has one revision
which means that whatever the initial implementation was, that sufficed. We
can’t tell if the design changed at all in response to its use in the client
code but given the nature of the bug I’d posit that any tweaking that did occur
during testing would have happened in the caller instead.</p>

<p class=MsoNormal>Switching to the call site changes we also see only a single
check-in. Looking at the diff for the file where the bug occurred we see that
there are five modified call sites – three of them directly compare the <span
style='font-family:"Courier New"'>Code</span> property and the other two use
the buggy comparison. What’s also noticeable is that the format of the error
handling code is slightly different in the former and latter cases – the code
is logically the same but spaced out differently.</p>

<p class=MsoNormal>If the original author copy-and-pasted the error block I’d
expect them all to look the same, which makes me wonder if they were, to start
with, but during testing when the silly mistake was fixed the formatting was
cleaned up too. This hypothesis gains a little more ground when we consider that
the three call sites that work are in code paths which are exercised by a smoke
test which is usually run by developers before check-in. In contrast the other
two sites are in a code path which is very rarely exercised and has to be done
manually, if anyone remembers.</p>

<h1>Epilogue</h1>

<p class=MsoNormal>Luckily this piece of code was authored by someone that was
still present in the team (although away at the time this showed up hence the somewhat
over-engineered analysis), consequently I have been able to find out which of
my various hypotheses, if any, were correct.</p>

<p class=MsoNormal>It turns out that the type was never intended to be used as
a value type but just a simple bucket for holding the two bits of error
information, i.e. a way to return multiple values in C#. The three call sites
that directly compared the <span style='font-family:"Courier New"'>Code</span>
property with the enumeration value <span style='font-family:"Courier New"'>None</span>
was the intended pattern of use and was fixed when the smoke test failed. The
other two were missed as they didn’t break any existing tests.</p>

<p class=MsoNormal>Although the smoke test (which is also run automatically on
deployment) picked up the bug it also goes to show that it does not help in
conveying the author’s intentions. One of the roles of lower level tests (e.g.
unit tests) along with verifying our expectations is to document how our code
is intended to be used and illustrates the scenarios we’ve considered. In this
instance we had to piece that together purely from the way the code is used in
production, which was inconsistent. The cost of rewriting would have been
minimal this time, but in other cases we’re not so lucky. It also shows that
code which is not tested at all automatically will be forgotten about. Once
again the broken feature didn’t matter this time but next time it might.</p>

<p class=MsoNormal>The only other niggle I had was why the two missed code
paths didn’t get picked up at commit time. The pre-commit review [3] is an
excellent point to jog our memory about such matters, particularly if the
change didn’t go smoothly, i.e. we wrote some code and we didn’t get it right
first time. To me the difference in code formatting between the working and
failing cases was another little sign that something was out of place. However
we need to be careful what our tools are showing us because the patch-style
diff made this apparent, whereas the full context diff showed that actually the
code was in keeping with its surroundings. So the author didn’t really miss
anything after all.</p>

<p class=MsoNormal>Somewhat ironically all the above analysis actually turned
out to be a waste of time. A static analysis tool highlighted some dead code
which when investigated further revealed that the only property used was the <span
style='font-family:"Courier New"'>None</span> one, for the happy path. All
other code paths resulted in an exception and therefore the <span
style='font-family:"Courier New"'>Error</span> class was in fact redundant and
the intervening methods could all be changed to return nothing (i.e. <span
style='font-family:"Courier New"'>void</span>). Once done all the error
handling blocks where the bug had shown up could be deleted too.</p>

<p class=MsoNormal>Did I say waste of time? As Ken Thompson once said “One of
my most productive days was throwing away 1,000 lines of code”. This was only
50 lines of code but it still feels like time well spent.</p>

<h1>References</h1>

<p class=MsoNormal>[1] Some objects are more equal than others, Roger Orr &amp;
Steve Love, ACCU 2011 Conference,<br>
<a href="https://accu.org/content/conf2011/Steve-Love-Roger-Orr-equals.pdf">https://accu.org/content/conf2011/Steve-Love-Roger-Orr-equals.pdf</a><br>
[2] In The Toolbox - Software Archaeology, C Vu 26-1,<br>
<a
href="http://www.chrisoldwood.com/articles/in-the-toolbox-software-archaeology.html">http://www.chrisoldwood.com/articles/in-the-toolbox-software-archaeology.html</a><br>
[3] In The Toolbox – Commit Checklist, C Vu 28-5,<br>
<a href="https://accu.org/index.php/journals/2306">https://accu.org/index.php/journals/2306</a></p>

<p class=MsoNormal>Chris Oldwood<br>
15 December 2016</p>

<h3>Biography</h3>

<p class=MsoNormal>Chris is a freelance programmer who started out as a bedroom
coder in the 80’s writing assembler on 8-bit micros. These days it's enterprise
grade technology in plush corporate offices. He also commentates on the
Godmanchester duck race and can be easily distracted via gort@cix.co.uk or
@chrisoldwood.</p>

</div>

</body>

</html>
