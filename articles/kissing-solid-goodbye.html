<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns:st1="urn:schemas-microsoft-com:office:smarttags"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=File-List href="kissing-solid-goodbye_files/filelist.xml">
<title>KISSing SOLID Goodbye</title>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="stockticker"/>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="address"/>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="Street"/>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="PersonName"/>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Chris Oldwood</o:Author>
  <o:LastAuthor>Chris Oldwood</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>1827</o:TotalTime>
  <o:Created>2014-08-05T22:25:00Z</o:Created>
  <o:LastSaved>2014-08-05T22:25:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>2590</o:Words>
  <o:Characters>14765</o:Characters>
  <o:Company>Co Productions Ltd</o:Company>
  <o:Lines>123</o:Lines>
  <o:Paragraphs>34</o:Paragraphs>
  <o:CharactersWithSpaces>17321</o:CharactersWithSpaces>
  <o:Version>11.9999</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:Compatibility>
   <w:BreakWrappedTables/>
   <w:SnapToGridInCell/>
   <w:WrapTextWithPunct/>
   <w:UseAsianBreakRules/>
   <w:UseWord2002TableStyleRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]--><!--[if !mso]><object
 classid="clsid:38481807-CA0E-42D2-BF39-B33AF135CC4D" id=ieooui></object>
<style>
st1\:*{behavior:url(#ieooui) }
</style>
<![endif]-->
<style>
<!--
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-GB;}
h1
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:16.0pt;
	font-family:Arial;
	mso-font-kerning:16.0pt;
	mso-ansi-language:EN-GB;}
h3
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:13.0pt;
	font-family:Arial;
	mso-ansi-language:EN-GB;}
h4
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:4;
	font-size:14.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:EN-GB;}
h5
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	mso-outline-level:5;
	font-size:13.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:EN-GB;
	font-style:italic;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{mso-style-link:" Char Char";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-GB;}
span.CharChar
	{mso-style-name:" Char Char";
	mso-style-locked:yes;
	mso-style-link:"Plain Text";
	font-family:"Courier New";
	mso-ascii-font-family:"Courier New";
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Courier New";
	mso-ansi-language:EN-GB;
	mso-fareast-language:EN-US;
	mso-bidi-language:AR-SA;}
@page Section1
	{size:612.0pt 792.0pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	mso-header-margin:35.4pt;
	mso-footer-margin:35.4pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:-132;
	mso-list-type:simple;
	mso-list-template-ids:-718738218;}
@list l0:level1
	{mso-level-tab-stop:74.6pt;
	mso-level-number-position:left;
	margin-left:74.6pt;
	text-indent:-18.0pt;}
@list l1
	{mso-list-id:-131;
	mso-list-type:simple;
	mso-list-template-ids:-425707240;}
@list l1:level1
	{mso-level-tab-stop:60.45pt;
	mso-level-number-position:left;
	margin-left:60.45pt;
	text-indent:-18.0pt;}
@list l2
	{mso-list-id:-130;
	mso-list-type:simple;
	mso-list-template-ids:456453232;}
@list l2:level1
	{mso-level-tab-stop:46.3pt;
	mso-level-number-position:left;
	margin-left:46.3pt;
	text-indent:-18.0pt;}
@list l3
	{mso-list-id:-129;
	mso-list-type:simple;
	mso-list-template-ids:870893940;}
@list l3:level1
	{mso-level-tab-stop:32.15pt;
	mso-level-number-position:left;
	margin-left:32.15pt;
	text-indent:-18.0pt;}
@list l4
	{mso-list-id:-128;
	mso-list-type:simple;
	mso-list-template-ids:-1845075050;}
@list l4:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:74.6pt;
	mso-level-number-position:left;
	margin-left:74.6pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l5
	{mso-list-id:-127;
	mso-list-type:simple;
	mso-list-template-ids:-1730902086;}
@list l5:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:60.45pt;
	mso-level-number-position:left;
	margin-left:60.45pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l6
	{mso-list-id:-126;
	mso-list-type:simple;
	mso-list-template-ids:83368132;}
@list l6:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:46.3pt;
	mso-level-number-position:left;
	margin-left:46.3pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l7
	{mso-list-id:-125;
	mso-list-type:simple;
	mso-list-template-ids:635702320;}
@list l7:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:32.15pt;
	mso-level-number-position:left;
	margin-left:32.15pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l8
	{mso-list-id:-120;
	mso-list-type:simple;
	mso-list-template-ids:634531270;}
@list l8:level1
	{mso-level-tab-stop:18.0pt;
	mso-level-number-position:left;
	margin-left:18.0pt;
	text-indent:-18.0pt;}
@list l9
	{mso-list-id:-119;
	mso-list-type:simple;
	mso-list-template-ids:1925459290;}
@list l9:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:18.0pt;
	mso-level-number-position:left;
	margin-left:18.0pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l10
	{mso-list-id:811412947;
	mso-list-type:hybrid;
	mso-list-template-ids:1640769712 67698689 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l10:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l11
	{mso-list-id:1464617291;
	mso-list-type:hybrid;
	mso-list-template-ids:315785860 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l11:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]-->
</head>

<body lang=EN-US link=blue vlink=purple style='tab-interval:36.0pt'>

<div class=Section1>

<h1 align=center style='text-align:center'><span lang=EN-GB>KISSing SOLID
Goodbye</span></h1>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<h3><span lang=EN-GB>Introduction</span></h3>

<p class=MsoNormal><span lang=EN-GB>The SOLID acronym and the design principles
behind it have been the guiding light for achieving good object-orientated (OO)
designs for as long as I can remember. It also features in nearly every job
interview I’ve attended, and yet I have to revise it because I can never
remember <i style='mso-bidi-font-style:normal'>exactly</i> what each of the
letters stands for!</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Over the last few years the reason for my
inability to remember these 5 core design principles has become apparent – they
are just not dissimilar enough to make them memorable. You would think that any
design review meeting where OO was being used as the fundamental paradigm would
feature one or more of these terms at almost every turn. But no, there are two <i
style='mso-bidi-font-style:normal'>other</i> terms which I find always seem
better suited and universally covers all the SOLID principles, but with much
less confusion – Separation of Concerns (SoC) and Program to an Interface
(PtaI).</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>This article attempts to highlight the seeming
redundancy in the SOLID principles and shows where either of the two terms above
could be used instead. This does not mean the SOLID principles themselves have
no intrinsic value, individually they may well hold a much deeper meaning, but
that at a higher level, which is where you might initially look for guidance, it
is more beneficial to keep it simple (KISS).</span></p>

<h3><span lang=EN-GB>Already On Shaky Ground</span></h3>

<p class=MsoNormal><span lang=EN-GB>In recent years I have seen a number of
talks where this theme has come up. Kevlin Henney, a man who seems to know a
thing or two about object-orientated design (amongst many other things), has
given a talk where he has deconstructed SOLID [KH1] and even provided (in
collaboration with Anders Norås) his own alternative – FLUID [KH2].</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>More recently I attended a talk at the 2014
ACCU conference by James Grenning [JG] about applying the SOLID principles to a
non-native OO language – C. During this talk he raised a similar question about
which are the two core principles of SOLID, and provided the Single
Responsibility Principle (<st1:stockticker w:st="on">SRP</st1:stockticker>) and
the Dependency Inversion Principle (DIP) as his selection.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Whilst the recognition that there is some
duplication within the SOLID principles is useful, I wanted to avoid the
confusion that would result from trying to always pick two of the five and then
use them consistently in any future discussion. What I realised is that I’ve
naturally always side-stepped this issue by using the terms Separation of
Concerns (SoC) and Program to an Interface (PtaI) instead.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>The remainder of this article looks at each
of the SOLID principles and frames them within the context of the two more
generalised ones. Rather than discuss them in acronym order I’ve therefore grouped
them in two so they are discussed collectively under the same banner.</span></p>

<h3><span lang=EN-GB>Separation of Concerns</span></h3>

<p class=MsoNormal><span lang=EN-GB>The basis of the Separation of Concerns
(SoC) principle is not specifically within software design; it transcends that
and applies to many other pursuits in life too, such as writing. Consequently
it is far less prescriptive in nature, instead preferring only to state that
“stuff” should be thought of in a different light to other “stuff”. The exact
nature of that stuff, how big it is, what it does, who owns it, etc. is entirely
context dependent. In terms of a software system we could be talking about the
client and server, or marshalling layer and business logic, or production code
and test code. It’s also entirely possible that the same two areas of
discussion be considered separate in one context and yet be united in another,
e.g. subsystems versus components.</span></p>

<h5><span lang=EN-GB>Single Responsibility Principle</span></h5>

<p class=MsoNormal><span lang=EN-GB>It should be fairly obvious that the Single
Responsibility Principle (<st1:stockticker w:st="on">SRP</st1:stockticker>) is
essentially just a more rigid form of SoC. The fact that an actual value has
been used to define how many responsibilities can be tolerated has lead some to
taking this principle literally, which is why I’ve found a personal preference
for the more general term.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>The subtext of <st1:stockticker w:st="on">SRP</st1:stockticker>
is that any class should only ever have one reason to change when that class
has a single, well-defined role within the system. For example, I once worked
on a codebase where a class was used to enrich an object model with display
names for presentation. The class that did the enriching looked similar to
this:</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB>public ProductNameEnricher : Enricher</span></p>

<p class=MsoPlainText><span lang=EN-GB>{<br>
<span style='mso-spacerun:yes'>  </span>public void Enrich(Order order)<br>
<span style='mso-spacerun:yes'>  </span>{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>   
</span>// code to make HTTP request to retrieve product details</span></p>

<p class=MsoPlainText><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>   
</span>// code to transform the object model<br>
<span style='mso-spacerun:yes'>  </span>}</span></p>

<p class=MsoPlainText><span lang=EN-GB>}</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>When it came to testing the class a virtual
method was introduced to allow the HTTP request to be mocked out; however
virtual methods in C# are often a design smell [CO]. Although it might seem
that the class has only one responsibility – enrich the object model with data
– in this instance it really has two:</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<ul style='margin-top:0cm' type=disc>
 <li class=MsoNormal style='mso-list:l10 level1 lfo12;tab-stops:list 36.0pt'><span
     lang=EN-GB>Make the remote HTTP call to retrieve the enrichment data</span></li>
 <li class=MsoNormal style='mso-list:l10 level1 lfo12;tab-stops:list 36.0pt'><span
     lang=EN-GB>Transform the object model to include the presentation data</span></li>
</ul>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>When it comes to further responsibilities
later, such as error handling of the remote call, caching of data, additional
data attributes, etc. the entire responsibility of the class grows and often
for more than one reason – HTTP request invocation or object model transformation.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Hence the two concerns can be split out
into separate classes that can then be independently tested (therefore removing
the need for the virtual method), e.g.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB>public ProductService : ProductFinder</span></p>

<p class=MsoPlainText><span lang=EN-GB>{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>public Product[] FindProducts(...)</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>   
</span>// code to make HTTP request to retrieve product details</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>}</span></p>

<p class=MsoPlainText><span lang=EN-GB>}</span></p>

<p class=MsoPlainText><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB>public ProductNameEnricher : Enricher</span></p>

<p class=MsoPlainText><span lang=EN-GB>{<br>
<span style='mso-spacerun:yes'>  </span>public void Enrich(Order order)<br>
<span style='mso-spacerun:yes'>  </span>{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>   
</span>var products = _proxy.FindProducts(...);</span></p>

<p class=MsoPlainText><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>   
</span>Enrich(order, products);<br>
<span style='mso-spacerun:yes'>  </span>}</span></p>

<p class=MsoPlainText><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>private static void Enrich(order, products)</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>   
</span>// code to transform the object model</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>}</span></p>

<p class=MsoPlainText><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>private readonly ProductFinder _proxy;</span></p>

<p class=MsoPlainText><span lang=EN-GB>}</span></p>

<h5><span lang=EN-GB>Interface Segregation Principle</span></h5>

<p class=MsoNormal><span lang=EN-GB>The clue that the Interface Segregation
Principle (<st1:stockticker w:st="on">ISP</st1:stockticker>) is just a
specialisation of SoC is the use of the word “segregation”. Replace it with
“separation”, jiggle the words around a little and soon you have Separation of
Interfaces.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>The idea behind <st1:stockticker w:st="on">ISP</st1:stockticker>
is that although a class may support a rich interface, its clients are quite
often only interested in a (common) subset of those at any one time.
Consequently it would be better to split the interface into just the surface
areas that are commonly of interest. A typical example of this is a class for manipulating
files or in-memory streams:</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB>public class MemoryStream</span></p>

<p class=MsoPlainText><span lang=EN-GB>{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>void Read(byte[] buffer, int count);</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>void Write(byte[] buffer, int count);</span></p>

<p class=MsoPlainText><span lang=EN-GB>}</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>It is more prevalent for a client to only
be concerned with reading or writing to/from a stream at any one time.
Therefore we can use the Extract Interface refactoring [MF] and split those
responsibilities into two separate interfaces:</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB>public interface Reader</span></p>

<p class=MsoPlainText><span lang=EN-GB>{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>void Read(byte[] buffer, int count);</span></p>

<p class=MsoPlainText><span lang=EN-GB>}</span></p>

<p class=MsoPlainText><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB>public interface Writer</span></p>

<p class=MsoPlainText><span lang=EN-GB>{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>void Write(byte[] buffer, int count);</span></p>

<p class=MsoPlainText><span lang=EN-GB>}</span></p>

<p class=MsoPlainText><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB>public class MemoryStream : Reader,
Writer</span></p>

<p class=MsoPlainText><span lang=EN-GB>{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>  </span>void
Read(byte[] buffer, int count);</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>void Write(byte[] buffer, int count);</span></p>

<p class=MsoPlainText><span lang=EN-GB>}</span></p>

<h3><span lang=EN-GB>Program to an Interface</span></h3>

<p class=MsoNormal><span lang=EN-GB>I first came across the expression “program
to an interface, not an implementation” when reading the seminal work on Design
Patterns by the Gang of Four [GoF]. The idea is that you should not (need to)
care about how a class is implemented, only that its interface provides you
with the semantics you require. Unlike languages such as Java and C#, C++ (amongst
others) does not support interfaces as a first-class concept which means the
notion of “interface” is somewhat subtler than just the methods declared within
an independently defined </span><span class=CharChar><span lang=EN-GB>interface</span></span><span
lang=EN-GB>-style type.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Where the two SOLID principles that fall
into the SoC category above are fairly easily to guess from their names alone,
the latter three are probably a little more obscure. And this, I feel, is in stark
contrast to the name of this encompassing principle.</span></p>

<h5><span lang=EN-GB>Liskov Substitution Principle</span></h5>

<p class=MsoNormal><span lang=EN-GB>The Liskov Substitution Principle (LSP) is
usually “explained” by quoting directly from it. What it boils down to is the proposition
that two types are related if one can be used in place of the other and the
code still works <i style='mso-bidi-font-style:normal'>exactly</i> as before.
One less intuitive example of this would be switching containers in C++:</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB>int sum(const
std::vector&lt;int&gt;&amp; values)</span></p>

<p class=MsoPlainText><span lang=EN-GB>{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>int sum = 0;<span style='mso-spacerun:yes'>  </span></span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>for (auto it = values.begin(); it != values.end(); ++it)</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>   
</span>sum += *it;</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>return sum;</span></p>

<p class=MsoPlainText><span lang=EN-GB>}</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>In this example the container could be
replaced with </span><span class=CharChar><span lang=EN-GB>std::dequeue</span></span><span
lang=EN-GB> or </span><span class=CharChar><span lang=EN-GB>std::list</span></span><span
lang=EN-GB> and the program would still compile, execute and give the exact same
result. And yet none of the C++ containers derive from a common “container interface”;
they merely implement the same set of methods to provide the same semantics and
can therefore be considered directly substitutable.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Interestingly Kevlin Henney, in the first
talk I saw about SOLID [KH1], made the observation that the Liskov Substitution
Principle states that a condition of the relationship is based on there being
“no change in the program’s behaviour”. The example above adheres precisely to
that constraint. However many interpret the principle as allowing substitution
if it conforms to the same abstract interface, despite the fact that the <i
style='mso-bidi-font-style:normal'>implementation</i> of that interface could
produce a program that does something completely different:</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB>public interface Writer</span></p>

<p class=MsoPlainText><span lang=EN-GB>{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>void Write(string message);</span></p>

<p class=MsoPlainText><span lang=EN-GB>}</span></p>

<p class=MsoPlainText><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB>public class FileWriter : Writer<br>
{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>void Write(string message);</span></p>

<p class=MsoPlainText><span lang=EN-GB>}</span></p>

<p class=MsoPlainText><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB>public class DatabaseWriter : Writer</span></p>

<p class=MsoPlainText><span lang=EN-GB>{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>void Write(string message);</span></p>

<p class=MsoPlainText><span lang=EN-GB>}</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Whichever way you interpret it, the ability
to substitute one implementation for another is predicated on the need of the
two implementations to confirm to the same interface, and for the consumer of
that interface to only invoke it in such a way that is compatible with the
common semantics of all potential implementations.</span></p>

<h5><span lang=EN-GB>Dependency Inversion Principle</span></h5>

<p class=MsoNormal><span lang=EN-GB>Whilst LSP considers what it means for the
client code to be able to consume similar types based on semantics, the
Dependency Inversion Principle (DIP) tackles how the implementation can be physically
partitioned without the client needing direct access to it. If the client only
depends on abstractions, then the opportunity to substitute different
implementations becomes possible. And because the details of the abstraction is
all that is required by the client, then the implementation can live in a
different part of the codebase.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>The “inversion” aspect comes from the idea
of a layered architecture where the consuming code that only relies on the
abstraction can live in the lower layers whilst the actual implementation can
live in the higher ones. In an onion-like architecture the abstractions can
live in the core whilst the implementations live in the outer service layers.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>The word “abstraction” could be considered
as synonymous with “interface” if considering it in the context of a
programming language that supports it as a first-class concept. In a duck
typing environment the subtler meaning is harder to translate as there is
nothing concrete to use as an aid in ensuring you’re only relying on the
abstract behaviour. Either way Program to an Interface is really another way of
saying Program to an Abstraction.</span></p>

<h5><span lang=EN-GB>Open/Closed Principle</span></h5>

<p class=MsoNormal><span lang=EN-GB>The Open/Closed Principle (OCP) has taken
quite a beating in recent times with the likes of <st1:PersonName w:st="on">Jo</st1:PersonName>n
Skeet [JS] putting it under the microscope. It appears that some have taken the
“closed for modification” aspect quite literally meaning that the code cannot
be modified under <i style='mso-bidi-font-style:normal'>any</i> circumstances,
even to fix a bug! Others have interpreted it a little more liberally and employed
polymorphism as a means to shield both the caller and 3<sup>rd</sup> party
(i.e. uncontrolled) implementations from change.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>For example, in languages where
polymorphism is not supported as a first-class concept, such as C, switching on
a field holding an object’s underlying “type” is a common way of varying
behaviour:</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB>switch (shape-&gt;type)</span></p>

<p class=MsoPlainText><span lang=EN-GB>{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>. . .</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>case Shape::Square:</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>   
</span>DrawSquare((<st1:Street w:st="on"><st1:address w:st="on">const Square</st1:address></st1:Street>*)shape);</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>   
</span>break;</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>case Shape::Circle:</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>   
</span>DrawCircle((<st1:Street w:st="on"><st1:address w:st="on">const Circle</st1:address></st1:Street>*)shape);</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>   
</span>break;</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>. . .</span></p>

<p class=MsoPlainText><span lang=EN-GB>}</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>With direct support for polymorphism the
client code reduces to a single line and is “open for extension” without
requiring modification of the caller by virtue of the fact that any new subclasses
will be automatically supported:</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB>shape-&gt;Draw();</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Similarly an implementation can be made
“open for extension” by breaking the functionality down into small, focused
methods that can be overridden piecemeal by a derived class, e.g. via the
Template Method design pattern [GoF-TM].</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><span lang=EN-GB>class DocumentPrinter</span></p>

<p class=MsoPlainText><span lang=EN-GB>{</span></p>

<p class=MsoPlainText><span lang=EN-GB>public:</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>virtual void Print(Document doc)</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>{</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>   
</span>PrintHeader(doc);</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>   
</span>PrintBody(doc);</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'>   
</span>PrintFooter(doc);</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>}</span></p>

<p class=MsoPlainText><span lang=EN-GB>protected:</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>virtual void PrintHeader();</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>virtual void PrintBody();</span></p>

<p class=MsoPlainText><span lang=EN-GB><span style='mso-spacerun:yes'> 
</span>virtual void PrintFooter();</span></p>

<p class=MsoPlainText><span lang=EN-GB>};</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>In both these cases the mechanism that
decouples the client from the implementation and allows the implementation to
be composed at an abstract-level is the interface. Whilst inheritance is a
common choice for implementation reuse, composition is more desirable due to
its lower coupling. The interface provides the means of describing the extensible
behaviour.</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>If taken in a literal sense the notion of
programming to an interface encourages the design of abstractions rather than
concrete types which in turn promotes looser coupling between caller and callee.
Consequently it also relaxes the need to rely on inheritance as the sole method
of extension and instead paves the way for composition to be used as an
alternative.</span></p>

<h3><span lang=EN-GB>Further Simplification</span></h3>

<p class=MsoNormal><span lang=EN-GB>In a private conversation about this idea Kevlin
Henney mused that you could even drop Program to an Interface as that is in
itself just another variation of the Separation of Concerns principle:</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:36.0pt'><span lang=EN-GB>“If you think
about it, Programming to an Interface is an articulation of separating
concerns: separate interface from implementation, have dependent code work in
terms of interface, i.e., separate from implementation dependency.”</span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-GB>Whilst in theory this is an interesting
observation, I not sure what, if any, practical value it has. Einstein once
said “Everything should be made as simple as possible, but no simpler”. The
reduction of SOLID down to just the Separation of Concerns and Program to an Interface
principles feels to me to be a valuable simplification, whilst the above would
be a step too far.</span></p>

<h3><span lang=EN-GB>Summary</span></h3>

<p class=MsoNormal><span lang=EN-GB>The goal of this article was to reduce the
five core SOLID principles to a more manageable and memorable number for the purposes
of everyday use. Instead of getting distracted with the finer details of SOLID
I’ve shown that the two more generalised principles of Program to an Interface and
Separation of Concerns are able to provide just as much gravitas to shape a software
design.</span></p>

<h3><span lang=EN-GB>Acknowledgements</span></h3>

<p class=MsoNormal><span lang=EN-GB>This article is merely a refinement of
similar ideas already put forward. As such I’m just standing on the shoulders
of the giants that are Kevlin Henney and James Grenning. The Overload peer
reviewers have also helped me stand on my tippy-toes to see that little bit
further afield.</span></p>

<h3><span lang=EN-GB>References</span></h3>

<p class=MsoNormal><span lang=EN-GB>[CO] Virtual Methods in C# Are a Design
Smell by <st1:PersonName w:st="on">Chris Oldwood</st1:PersonName> - <a
href="http://chrisoldwood.blogspot.co.uk/2013/09/virtual-methods-in-c-are-design-smell.html">http://chrisoldwood.blogspot.co.uk/2013/09/virtual-methods-in-c-are-design-smell.html</a></span></p>

<p class=MsoNormal><span lang=EN-GB>[GoF] Design Patterns: Elements of Reusable
Object-Oriented Software by Ralph <st1:PersonName w:st="on">Jo</st1:PersonName>hnson,
<st1:PersonName w:st="on">Jo</st1:PersonName>hn Vlissides, Richard Helm, and
Erich Gamma</span></p>

<p class=MsoNormal><span lang=EN-GB>[GoF-TM] Template Method from Design
Patterns - <a href="http://en.wikipedia.org/wiki/Template_method_pattern">http://en.wikipedia.org/wiki/Template_method_pattern</a></span></p>

<p class=MsoNormal><span lang=EN-GB>[JG] Designing SOLID C by James Grenning (ACCU
Conference 2014) - <a
href="http://www.slideshare.net/JamesGrenning/solid-c-accu2014key">http://www.slideshare.net/JamesGrenning/solid-c-accu2014key</a></span></p>

<p class=MsoNormal><span lang=EN-GB>[JS] The Open-Closed Principle, in review
by <st1:PersonName w:st="on">Jo</st1:PersonName>n Skeet - <a
href="http://msmvps.com/blogs/jon_skeet/archive/2013/03/15/the-open-closed-principle-in-review.aspx">http://msmvps.com/blogs/jon_skeet/archive/2013/03/15/the-open-closed-principle-in-review.aspx</a></span></p>

<p class=MsoNormal><span lang=EN-GB>[KH1] Will the Real OO Please Stand Up? by
Kevlin Henney (ACCU 2011 conference) - <a
href="http://accu.org/content/conf2011/Kevlin-Henney-Will-the-Real-OO-Please-Stand-Up.pdf">http://accu.org/content/conf2011/Kevlin-Henney-Will-the-Real-OO-Please-Stand-Up.pdf</a>
and <a href="http://www.slideshare.net/Kevlin/solid-deconstruction">http://www.slideshare.net/Kevlin/solid-deconstruction</a></span></p>

<p class=MsoNormal><span lang=EN-GB>[KH2] SOLID deconstruction by Kevlin Henney
(ACCU 2012 conference) - <a
href="http://accu.org/content/conf2012/Kevlin_SOLID_Deconstruction.pdf">http://accu.org/content/conf2012/Kevlin_SOLID_Deconstruction.pdf</a>
and <a href="http://www.slideshare.net/Kevlin/introducing-the-fluid-principles">http://www.slideshare.net/Kevlin/introducing-the-fluid-principles</a></span></p>

<p class=MsoNormal><span lang=EN-GB>[MF] Refactoring: Improving the Design of
Existing Code by Martin Fowler - <a
href="http://refactoring.com/catalog/extractInterface.html">http://refactoring.com/catalog/extractInterface.html</a></span></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><st1:PersonName w:st="on"><span lang=EN-GB>Chris Oldwood</span></st1:PersonName></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-GB><span
style='mso-element:field-begin'></span><span
style='mso-spacerun:yes'> </span>SAVEDATE<span style='mso-spacerun:yes'> 
</span>\@ &quot;dd MMMM yyyy&quot;<span style='mso-spacerun:yes'>  </span>\*
MERGEFORMAT <span style='mso-element:field-separator'></span></span><![endif]--><span
lang=EN-GB><span style='mso-no-proof:yes'>17 July 2014</span></span><!--[if supportFields]><span
lang=EN-GB><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=MsoNormal><span lang=EN-GB><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><u><span lang=EN-GB>Bio<o:p></o:p></span></u></p>

<p class=MsoNormal><span lang=EN-GB>Chris is a freelance developer who started
out as a bedroom coder in the 80’s writing assembler on 8-bit micros; these
days it’s C++ and C#. He also commentates on the Godmanchester duck race and
can be contacted via <a href="mailto:gort@cix.co.uk">gort@cix.co.uk</a> or
@chrisoldwood.</span></p>

</div>

</body>

</html>
