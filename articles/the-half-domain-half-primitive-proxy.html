<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=Generator content="Microsoft Word 12 (filtered)">
<title>The Half-Domain/Half-Primitive Proxy</title>
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Cambria;
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:10.0pt;
	margin-left:0cm;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
h1
	{mso-style-link:"Heading 1 Char";
	margin-top:24.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Cambria","serif";
	color:#21798E;}
h2
	{mso-style-link:"Heading 2 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:13.0pt;
	font-family:"Cambria","serif";
	color:#2DA2BF;}
h3
	{mso-style-link:"Heading 3 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Cambria","serif";
	color:#2DA2BF;}
h4
	{mso-style-link:"Heading 4 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Cambria","serif";
	color:#2DA2BF;
	font-style:italic;}
h5
	{mso-style-link:"Heading 5 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Cambria","serif";
	color:#16505E;
	font-weight:normal;}
h6
	{mso-style-link:"Heading 6 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Cambria","serif";
	color:#16505E;
	font-weight:normal;
	font-style:italic;}
p.MsoHeading7, li.MsoHeading7, div.MsoHeading7
	{mso-style-link:"Heading 7 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Cambria","serif";
	color:#404040;
	font-style:italic;}
p.MsoHeading8, li.MsoHeading8, div.MsoHeading8
	{mso-style-link:"Heading 8 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Cambria","serif";
	color:#2DA2BF;}
p.MsoHeading9, li.MsoHeading9, div.MsoHeading9
	{mso-style-link:"Heading 9 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Cambria","serif";
	color:#404040;
	font-style:italic;}
p.MsoCaption, li.MsoCaption, div.MsoCaption
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:10.0pt;
	margin-left:0cm;
	font-size:9.0pt;
	font-family:"Calibri","sans-serif";
	color:#2DA2BF;
	font-weight:bold;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{mso-style-link:"Title Char";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:15.0pt;
	margin-left:0cm;
	border:none;
	padding:0cm;
	font-size:26.0pt;
	font-family:"Cambria","serif";
	color:#343434;
	letter-spacing:.25pt;}
p.MsoTitleCxSpFirst, li.MsoTitleCxSpFirst, div.MsoTitleCxSpFirst
	{mso-style-link:"Title Char";
	margin:0cm;
	margin-bottom:.0001pt;
	border:none;
	padding:0cm;
	font-size:26.0pt;
	font-family:"Cambria","serif";
	color:#343434;
	letter-spacing:.25pt;}
p.MsoTitleCxSpMiddle, li.MsoTitleCxSpMiddle, div.MsoTitleCxSpMiddle
	{mso-style-link:"Title Char";
	margin:0cm;
	margin-bottom:.0001pt;
	border:none;
	padding:0cm;
	font-size:26.0pt;
	font-family:"Cambria","serif";
	color:#343434;
	letter-spacing:.25pt;}
p.MsoTitleCxSpLast, li.MsoTitleCxSpLast, div.MsoTitleCxSpLast
	{mso-style-link:"Title Char";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:15.0pt;
	margin-left:0cm;
	border:none;
	padding:0cm;
	font-size:26.0pt;
	font-family:"Cambria","serif";
	color:#343434;
	letter-spacing:.25pt;}
p.MsoSubtitle, li.MsoSubtitle, div.MsoSubtitle
	{mso-style-link:"Subtitle Char";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:10.0pt;
	margin-left:0cm;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Cambria","serif";
	color:#2DA2BF;
	letter-spacing:.75pt;
	font-style:italic;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p.MsoNoSpacing, li.MsoNoSpacing, div.MsoNoSpacing
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:10.0pt;
	margin-left:36.0pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.0pt;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.0pt;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:10.0pt;
	margin-left:36.0pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoQuote, li.MsoQuote, div.MsoQuote
	{mso-style-link:"Quote Char";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:10.0pt;
	margin-left:0cm;
	line-height:115%;
	font-size:10.0pt;
	font-family:"Calibri","sans-serif";
	color:black;
	font-style:italic;}
p.MsoIntenseQuote, li.MsoIntenseQuote, div.MsoIntenseQuote
	{mso-style-link:"Intense Quote Char";
	margin-top:10.0pt;
	margin-right:46.8pt;
	margin-bottom:14.0pt;
	margin-left:46.8pt;
	line-height:115%;
	border:none;
	padding:0cm;
	font-size:10.0pt;
	font-family:"Calibri","sans-serif";
	color:#2DA2BF;
	font-weight:bold;
	font-style:italic;}
span.MsoSubtleEmphasis
	{color:gray;
	font-style:italic;}
span.MsoIntenseEmphasis
	{color:#2DA2BF;
	font-weight:bold;
	font-style:italic;}
span.MsoSubtleReference
	{font-variant:small-caps;
	color:#DA1F28;
	text-decoration:underline;}
span.MsoIntenseReference
	{font-variant:small-caps;
	color:#DA1F28;
	letter-spacing:.25pt;
	font-weight:bold;
	text-decoration:underline;}
span.MsoBookTitle
	{font-variant:small-caps;
	letter-spacing:.25pt;
	font-weight:bold;}
p.MsoTocHeading, li.MsoTocHeading, div.MsoTocHeading
	{margin-top:24.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Cambria","serif";
	color:#21798E;
	font-weight:bold;}
span.Heading3Char
	{mso-style-name:"Heading 3 Char";
	mso-style-link:"Heading 3";
	font-family:"Cambria","serif";
	color:#2DA2BF;
	font-weight:bold;}
span.TitleChar
	{mso-style-name:"Title Char";
	mso-style-link:Title;
	font-family:"Cambria","serif";
	color:#343434;
	letter-spacing:.25pt;}
span.Heading1Char
	{mso-style-name:"Heading 1 Char";
	mso-style-link:"Heading 1";
	font-family:"Cambria","serif";
	color:#21798E;
	font-weight:bold;}
span.Heading2Char
	{mso-style-name:"Heading 2 Char";
	mso-style-link:"Heading 2";
	font-family:"Cambria","serif";
	color:#2DA2BF;
	font-weight:bold;}
span.Heading4Char
	{mso-style-name:"Heading 4 Char";
	mso-style-link:"Heading 4";
	font-family:"Cambria","serif";
	color:#2DA2BF;
	font-weight:bold;
	font-style:italic;}
span.Heading5Char
	{mso-style-name:"Heading 5 Char";
	mso-style-link:"Heading 5";
	font-family:"Cambria","serif";
	color:#16505E;}
span.Heading6Char
	{mso-style-name:"Heading 6 Char";
	mso-style-link:"Heading 6";
	font-family:"Cambria","serif";
	color:#16505E;
	font-style:italic;}
span.Heading7Char
	{mso-style-name:"Heading 7 Char";
	mso-style-link:"Heading 7";
	font-family:"Cambria","serif";
	color:#404040;
	font-style:italic;}
span.Heading8Char
	{mso-style-name:"Heading 8 Char";
	mso-style-link:"Heading 8";
	font-family:"Cambria","serif";
	color:#2DA2BF;}
span.Heading9Char
	{mso-style-name:"Heading 9 Char";
	mso-style-link:"Heading 9";
	font-family:"Cambria","serif";
	color:#404040;
	font-style:italic;}
span.SubtitleChar
	{mso-style-name:"Subtitle Char";
	mso-style-link:Subtitle;
	font-family:"Cambria","serif";
	color:#2DA2BF;
	letter-spacing:.75pt;
	font-style:italic;}
span.QuoteChar
	{mso-style-name:"Quote Char";
	mso-style-link:Quote;
	color:black;
	font-style:italic;}
span.IntenseQuoteChar
	{mso-style-name:"Intense Quote Char";
	mso-style-link:"Intense Quote";
	color:#2DA2BF;
	font-weight:bold;
	font-style:italic;}
@page WordSection1
	{size:595.3pt 841.9pt;
	margin:72.0pt 72.0pt 72.0pt 72.0pt;}
div.WordSection1
	{page:WordSection1;
	width: 600px;
	margin-left: auto;
	margin-right: auto;}
-->
</style>

</head>

<body lang=EN-GB link=blue vlink=purple>

<div class=WordSection1>

<div style='border:none;border-bottom:solid #2DA2BF 1.0pt;padding:0cm 0cm 4.0pt 0cm'>

<p class=MsoTitle><span lang=X-NONE>The Half-Domain/Half-Primitive Proxy</span></p>

</div>

<p class=MsoNormal>I recently spent a few years working in the retail sector
building web APIs. Some of these projects were greenfield but I also worked on
a number of existing (brownfield) services too. As you might expect working on variations
of a theme you start to see patterns developing in the way the services are
designed and implemented.</p>

<p class=MsoNormal>There are apparently only so many ways you can skin a cat
and once you have chosen your programing language and web service framework many
things naturally fall into place as you have bought into their paradigms.
Plenty has been written about these frameworks and how to use them but that’s
not the pattern of focus here, this article looks at the other end of the wire
– the client proxy – an area with less attention to detail.</p>

<h1><span lang=X-NONE>Service Proxy Use Cases</span></h1>

<p class=MsoNormal>When building a web API the ultimate deliverable is the
service itself, more commonly these days a REST API using JSON as the
wire-level content format. If you’re building an API in the enterprise you may
have to support XML too but that seems to be heavily declining as JSON has been
the lingua-franca of Internet APIs for some time. The service might be deployed
on premise or in the cloud and could be self-hosted, i.e. you own the hosting
process, or run as part of a shared web service such as IIS. Hence any client
that wants to talk to your service needs to be fluent in HTPP and JSON too.
There are plenty of libraries available for handling these low-level details;
the client use cases we are interested in though sit just a little higher up
the call stack.</p>

<h2><span lang=X-NONE>Acceptance Testing</span></h2>

<p class=MsoNormal>The most likely client in the beginning will be the set of
acceptance tests used to describe and verify the service’s various behaviours.
In something reasonably small and well defined like a web service the balance
of the testing pyramid [1] may be skewed in favour of more customer tests and
less programmer tests as they provide the perfect opportunity for outside-in
[2] development. Yes, unit tests are still highly useful for those behaviours
which are much harder to invoke from the outside without exposing back-door
endpoints, such as error recovery, but the lion’s share can be invoked by an
external client.</p>

<p class=MsoNormal>Therefore our primary need for a proxy is to facilitate the
writing of acceptance tests for our service. Our test cases need to be able to
invoke our API in a variety of ways to ensure we cover both the happy paths but
also the less happy ones too by ensuring both malicious and accidentally
malformed inputs are correctly handled and the caller is provided with as much
information as possible to correct the error of their ways. For example we
might write a test like this to check that a REST resource is correctly
secured:</p>

<p class=MsoNormal><span style='font-family:"Courier New"'>[TestFixture]<br>
public class orders_are_secured<br>
{<br>
  [Test]<br>
  public void request_returns_unauthorised_when_token_is_missing()<br>
  {<br>
    const string customerId = “123456789”;<br>
    var request = new FetchOrdersRequest(customerId);<br>
    request.RemoveHeader(&quot;Authorization&quot;);<br>
<br>
    var proxy = new ShopProxy();<br>
    var response = proxy.Send(request);<br>
<br>
    Assert.That(response.StatusCode, Is.EqualTo(401));<br>
  }<br>
}</span></p>

<h2><span lang=X-NONE>Deployment / Monitoring / Smoke Testing</span></h2>

<p class=MsoNormal>While acceptance tests take care of all the fine details
about how the service works you probably want something a little simpler to
just “kick the tyres” during (or just after) a deployment. You could repurpose
the acceptance tests, minus any that use private APIs to perturb the clock or
other internals details, but they are often overkill when all you really want
to do is exercise some core customer journeys. For example one journey might be
to find the most recent order for a known test customer (as we’ve just
exercised the journey to place an order for them and already know it succeeded):</p>

<p class=MsoNormal><span style='font-family:"Courier New"'>public static void
ViewLatestOrder(CustomerId customerId, ...)<br>
{<br>
  var shop = new ShopProxy();<br>
  var token = shop.AcquireCustomerToken(customerId, credentials);<br>
  var orders = shop.FetchLatestOrders(customerId, token);<br>
  . . .<br>
}</span></p>

<p class=MsoNormal>Deployment isn’t the only time when you might want to
exercise your API in this way though; you’ll want to keep doing it all through
the day as part of your monitoring strategy. The use of “canaries” is a common
technique for firing requests into your system at repeated intervals to allow
you to record how it’s behaving. If you can capture some performance data at
the same time [3] you have an easy way to track the change in performance over
time from the client’s perspective (if you can invoke it from another data
centre) and correlate that with the load at those moments in time.</p>

<p class=MsoNormal>Even during development or bug fixing it’s still useful to
be able to run the smoke tests quickly over your local build, especially if the
acceptance tests take some shortcuts, such as hosting the API in-process. For
example, whenever changing something other than functional code that will
affect the set of deployed artefacts, like adding or removing assemblies or updating
3<sup>rd</sup> party package, it’s useful to do a full build and deploy <i>locally</i>
and then run the smoke tests before committing. This is to ensure nothing has
been left out, like a configuration setting or binary that will cause the
service to choke on start-up and unnecessarily disrupt the delivery pipeline.</p>

<h2><span lang=X-NONE>Support</span></h2>

<p class=MsoNormal>In my recent “Toolbox” column <i>Libraries, Console Apps and
GUIs</i> [4] I described how I’ve found that home-grown tools often have a
habit of being useful to a wider audience, such as a support team. Hence when
you have a simple tool that can exercise a few basic journeys you already have
all the code you need to provide fine-grained access to your service through,
say, a command line interface.</p>

<p class=MsoNormal>For something like a REST API which has been built on open
protocols and for which the Internet provides a bewildering array of tools it
might seem a little wasteful putting a custom tool together. In the early life
of an HTTP service a tool like <span style='font-family:"Courier New"'>CURL</span>
or a Chrome extension such as Postman can provide everything you need to poke
the endpoints and see the responses. However once you start needing to make
calls out to more than once service to accomplish a bigger task, such as
requesting an access token from an authentication service, the friction starts
to accumulate.</p>

<p class=MsoNormal>At this point that shell script which fuses together <span
style='font-family:"Courier New"'>CURL</span> for the HTTP aspects, along with,
say, <span style='font-family:"Courier New"'>JQ</span> for the JSON parsing
starts to become a little unwieldy, especially if you’re on the Windows
platform where these tools aren’t installed by default. A Windows heavy
enterprise will probably use an NTLM based proxy too for accessing the outside
world which can create another world of pain if you’re trying to use open
source tooling [5]. Hence putting together a little .Net based tool (or
PowerShell script which uses .Net under the covers) can hide this unnecessary
noise from the (support) user. Fortunately CURL is one of those tools which can
punch its way through an NTLM proxy (with the relevant command line switches),
although you still need to watch out for certificate problems if the
organisation uses its own. (Self-signed certificates are a common technique in
the enterprise at the moment for monitoring traffic to the outside world.)</p>

<p class=MsoNormal>With the various API endpoints exposed through a little
command line tool it makes it really easy to automate simple support and
administration tasks. Instead of stitching together low-level tools like <span
style='font-family:"Courier New"'>CURL</span> and <span style='font-family:
"Courier New"'>JQ</span> you can work at a higher level of abstraction which
makes the already daunting tasks of comprehending a shell script just that
little bit easier. For example I might need to check the loyalty points balance
for an arbitrary customer that would first require a special, short-lived
“administration token” to be obtained using my separate <i>administrative</i>
credentials:</p>

<p class=MsoNormal><span style='font-family:"Courier New"'>&gt; PointsAdmin
view-balance --customer 123456 --administrator %MY_ADMIN_LOGIN% --password
%MY_ADMIN_PASSWORD%<br>
42.5</span></p>

<p class=MsoNormal>This approach can also be used as an alternative to
monkeying around with the database. While there may be times when a one-off database
tweak might be necessary it’s preferable to factor support and administration
functions directly into the API (secured of course) so that the chances of
corrupting any data are minimised by accidentally violating some invariant
which is enforced in the service code rather than the database (a necessity
with the newer document-oriented databases).</p>

<h2><span lang=X-NONE>Client SDK</span></h2>

<p class=MsoNormal>One natural by-product of creating an independent proxy for
your service is that you have something which other service consumers might
find useful, assuming of course they are using the same language or runtime. In
the enterprise arena where the desire is to minimise the number of unique
languages and runtimes in play it’s highly likely that one more consumers may
find your wares of interest. (With the CLR and JVM the programming language
does not have to be the same but in my experience enterprises still limit the
number of languages even on these runtimes despite the built-in interoperability
benefits.)</p>

<p class=MsoNormal>That said it’s easy for shared libraries like this to become
a burden on the team, especially when the consumers assume they form a
supported part of the product. If that <i>is</i> a responsibility the team
wishes to take on, then so be it, but unless this is agreed upon the proxy
should be considered nothing more than a “leg up” to help a consumer bootstrap
their use of the service. They should have the choice of whether to fork your
source and customise it, or build their own. Removing this supporting role often
goes against the commonly established enterprise goal of maximising efficiency,
but it is necessary to ensure the higher purpose of decoupling the service and
consumer deliveries where possible.</p>

<p class=MsoNormal>On the face of it providing a proxy may not seem like much
of a burden but the interfaces and data types are only one part of what it
takes to write a solid, reliable client. Once you start factoring in logging [6],
instrumentation, and monitoring [7] the need to provide hooks to allow your
code to interoperate with whatever product choices the caller has chosen for
these concerns adds to the complexity. If you plan to use your own technical
and domain types [8] too, e.g. <span style='font-family:"Courier New"'>Optional</span>,
<span style='font-family:"Courier New"'>Date</span>, <span style='font-family:
"Courier New"'>CustomerId</span>, etc. then these need to be easily accessible
so the consumer doesn’t need to ship half your service libraries as well as
their own just to use it.</p>

<h1><span lang=X-NONE>Typical Evolution - Multiple Choices</span></h1>

<p class=MsoNormal>In my experience these various use cases, when they do
eventually appear, will end up as a discrete set of different libraries or
tools. Consequently by the time the pattern begins to surface the design has
long passed the point where a simple refactoring can bring together the various
strands into a single coherent component. What follows below is one common path
I’ve observed.</p>

<h2><span lang=X-NONE>Acceptance Tests</span></h2>

<p class=MsoNormal>The proxy used in the acceptance tests will no doubt evolve
in a very rough-and-ready fashion. Being “merely” test code there will be
little thought put into how the tests need to talk to the service under inspection
and so the code will probably suffer from a form of Primitive Obsession [9]
where the native HTTP client library will feature heavily. Eventually common utility
methods will be introduced but no serious refactoring will take place and the
need to verify both happy and error paths will lead to a smorgasbord of
overloads with some throwing and others returning values. Being used solely for
testing (at this point) there’s a good chance that the test framework assertion
methods will be interwoven with the proxy code (rather than there being a clear
boundary between “sending the request” and “validating the response”), e.g.<br>
<br>
<span style='font-family:"Courier New"'>public string OpenTestAccount(string customer)<br>
{<br>
  var request = new OpenAccountRequest{ Customer = customer };<br>
  var response = ShopProxy.Send&lt;OpenAccountResponse&gt;(request);<br>
<br>
  Assert.That(response.StatusCode, Is.EqualTo(200));<br>
  Assert.That(response.AccountId, Is.Not.Empty);<br>
<br>
  return response.AccountId;<br>
}<br>
<br>
[Test]<br>
public void closing_an_account_returns_ok()<br>
{<br>
  var accountId = OpenTestAccount(“. . .”);<br>
<br>
  var request = new CloseAccountRequest{ AccountId = accountId };<br>
  var response = ShopProxy.Send(request);<br>
<br>
  Assert.That(response.StatusCode, Is.EqualTo(200));<br>
}</span></p>

<p class=MsoNormal>In the early days of an API where you’re not even sure what conventions
it will adopt, such as what URL structure to use, query parameters vs body, headers,
etc. the API needs to evolve quickly. If the initial focus is on the happy path
then the size of the proxy interface may be quite small and easily maintainable
but as the error paths begin to play a role and more control is needed around
the URL, headers and body content, the more work is needed to keep everything
in sync and make sure that every test really does exercise the behaviour it
thinks it does. If the API changes quite radically, e.g. a change in the
“resource” structure, then a lot of ad-hoc test code might need fixing up –
treating test code as a first class citizen is important for supporting rapid
change.</p>

<h2><span lang=X-NONE>Deployment / Monitoring / Smoke Tests</span></h2>

<p class=MsoNormal>As alluded to earlier if the service is based on open
protocols, like HTTP, then it’s certainly possible to cobble together whatever
you need from established open source tools, like CURL. Deployment tools like
Ansible and dynamic languages like Python have plenty of modules for both
high-level tasks, like configuring a machine, and lower-level tasks, such as
testing port connectivity and making basic transport requests. Therefore it’s
quite possible that unless the development and deployment teams are aligned (if
they’re not one and the same) they will each use what they know best and create
their own method for testing the service’s availability. This isn’t a problem
per-se unless the development team wants to iterate quickly over their API and
it causes friction down the delivery pipeline due to unexpectedly breaking the
deployment and monitoring processes.</p>

<p class=MsoNormal>This is one of the reasons why operations’ concerns must be
factored into any user stories and the definition of “done” should include
monitoring and alerting updates as well the more obvious developer oriented
tasks.</p>

<h2><span lang=X-NONE>Support</span></h2>

<p class=MsoNormal>A similar argument can probably be made for any support
requirements – they will use whatever off-the-shelf tools they can find or are
already used to. Similarly if they have a choice between directly accessing the
database and trying to go through the API, the path of least resistance leads
to the former choice unless their needs are also explicitly factored into the
service design and tooling.</p>

<h2><span lang=X-NONE>Client SDK</span></h2>

<p class=MsoNormal>The reason for choosing open protocols is that it affords
any consumers the ability to choose what technologies they prefer for accessing
the service. Therefore on the principle of “use before reuse” [10] there is
unlikely to be a direct need to provide a formal client proxy unless the team
happens to be responsible for maintaining a number of <i>related</i> services
and therefore there is something to be gained from having a component that can
be shared.</p>

<p class=MsoNormal>What is highly unlikely to occur (unless it’s a conscious
decision) is that the proxy developed for the acceptance tests can be easily
factored out into a separate component that is then reusable in both scenarios.
It is more likely the other way around, i.e. reusing the client SDK for some
aspects of the acceptance tests (happy paths), if the refactoring costs are considered
worth it.</p>

<h1><span lang=X-NONE>Pattern Vocabulary</span></h1>

<p class=MsoNormal>Although the pattern uses the term “proxy” it should be
pointed out that this use is not entirely in keeping with the classic Proxy
pattern described in the seminal book on Design Patterns by “The Gang of Four”
[11]. One of the key traits of the pattern described in that book is that the
proxy exposes the <i>same</i> interface as the underlying object. In essence a
proxy in their eyes is entirely transparent and acts purely as a surrogate for
the real deal. In this article the <i>underlying</i> transport class provided
by the language runtime fulfils that role, which for .Net would be <span
style='font-family:"Courier New"'>HttpClient</span> for the HTTP protocol.</p>

<p class=MsoNormal>One of the most important aspects of the Design Patterns
movement was the attempt to introduce a common vocabulary to make it easier to
talk about similar design concepts. Hence it feels a little awkward not to
stick to the letter of the law, so to speak, and use it for something which is
more loosely related. For me proxies have been placeholders for remote objects
and services ever since I wrote my first RPC code on a Sun 3/60 workstation at
university and therefore I feel the surrogate aspect of this design is in
keeping with their pattern, even if the exposure of a different interface is
not. Hopefully no one will be confused by my choice of term because I’ve
painted outside the lines in a few places.</p>

<p class=MsoNormal>That does not mean though that we are entirely excluded from
using the other patterns in that seminal work for describing our “creation”. On
the contrary this pattern is essentially just the composition of two of their other
classics – Adapter and Façade.</p>

<h1><span lang=X-NONE>Pattern Structure</span></h1>

<p class=MsoNormal>The following diagram shows the general shape of the
pattern:</p>

<p class=MsoNormal>

<table cellpadding=0 cellspacing=0 align=left>
 <tr>
  <td width=7 height=33></td>
 </tr>
 <tr>
  <td></td>
  <td><img width=564 height=173
  src="the-half-domain-half-primitive-proxy_files/image001.png"></td>
 </tr>
</table>

 &nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<br clear=ALL>

<h2><span lang=X-NONE>Back-End Façade</span></h2>

<p class=MsoNormal>Working slightly unusually from the network end back up to
the caller we begin with the underlying transport class that provides the <i>true</i>
proxy for the service we want to access which is often provided by the language
runtime. Being a general purpose class this needs to exposes everything that
anyone would ever likely want to do to access a service using the type of
network transport in question. For something like HTTP this could include
everything ranging from simple JSON REST APIs up to streaming content of
different media types using different encodings.</p>

<p class=MsoNormal>Our requirements however are often far more meagre and what
we initially need is to reduce that all-encompassing interface down into
something simpler and more focused. For example if we’re talking to a
microservice using HTTP and JSON we can simplify a lot of the interface and
make many more assumptions about the responses. In design pattern terms this
simplification is known as a façade.</p>

<h2><span lang=X-NONE>Front-End Adapter</span></h2>

<p class=MsoNormal>With the transport layer interface largely simplified,
albeit still with some elements of complexity to allow ourselves enough control
over the more unusual requests we’ll be sending, such as during testing, we now
need to hide that grunge for the client that isn’t interested in any of that
but wants something richer and more intuitive.</p>

<p class=MsoNormal>Hence the front-facing half of the proxy is more akin to an
Adapter from the original Gang of Four book. In this instance its role is to
present an interface to the caller that deals in rich types, which is typically
why we’re using a statically typed language, and convert them into the more
text oriented world of the façade. Likewise the return path transforms the
responses from text to types and also maps any failures into a more suitable
error mechanism.</p>

<p class=MsoNormal><i>There is an element of further simplification going on here
too, so it is also façade-like in nature, but its primary purpose is to provide
a different interface rather than a simpler version of the same one.</i></p>

<h1><span lang=X-NONE>Pattern Interfaces</span></h1>

<p class=MsoNormal>Now that we have a grasp on the various forces that are
driving the design and a feel for the overall pattern shape we can look at the
interfaces of the two halves in more detail. This time we’ll look at them in
the more conventional order starting with the consumer’s perspective and then
moving behind the curtain.</p>

<h2><span lang=X-NONE>The Domain Interface</span></h2>

<p class=MsoNormal>For normal production use it is desirable to move away from
a typical “stringly typed” interface and instead traffic in rich domain types
like dates, product identifiers and enumerations. At this level, if you’re
using a statically type language, then the type system can work for you, both
to help catch silly mistakes but also provide you with hints through tools like
IntelliSense.</p>

<p class=MsoNormal>To invoke a simple query on the service shouldn’t require
you to know how to format the URL, or what goes in the header, or how dates and
times need to be passed in JSON (which has no native date or time type). The
domain level interface abstracts all of this away and hides enough of the
transport details to make remote calls appear less remote (avoiding overly
chatty interfaces).</p>

<p class=MsoNormal><span style='font-family:"Courier New"'>var shop = new
ShopProxy(hostname);<br>
var lastMonth = DateTime.Now.AddDays(-30);<br>
var orders = shop.FindOrders(lastMonth, Status.Delivered);</span></p>

<p class=MsoNormal>The network is unreliable though and so error handling
probably takes the form of exceptions as recovery from low-level transient
request failures will likely take the form of continuous retries somewhere further
up the stack. A basic exception hierarchy can support the most common
catastrophic error scenarios, such as timeouts, disconnections, service
failures (e.g. <span style='font-family:"Courier New"'>500</span> and <span
style='font-family:"Courier New"'>503</span>), client errors (e.g. <span
style='font-family:"Courier New"'>400</span>), etc. Buried in these exceptions might
be more fine-grained diagnostic context but the exception type itself should be
enough to indicate if it’s a (fast) retry scenario, there is something more
fundamentally broken at the client end and a (slow) retry or triaging is
required, or the request is just broken and we need to “return to sender”.</p>

<p class=MsoNormal>While exceptions might be a suitable technique for handling
transport level failures there are a number of HTTP error codes which fall into
the less exceptional end of the spectrum, such as 404 which means a resource
couldn’t be found. While this might be down to a bug in your client (you’ve
requested the wrong thing due to a URL formatting error) if there is a chance,
either through concurrency or due to later deletion, that it might not exist
then an <span style='font-family:"Courier New"'>Optional&lt;T&gt;</span> would
probably be a better return type, e.g.</p>

<p class=MsoNormal><span style='font-family:"Courier New"'>public Optional&lt;Balance&gt;
FetchBalance(AccountId accountId)<br>
{<br>
  var request = new FetchBalanceRequest(accountId);<br>
  var response = proxy.Send&lt;BalanceResponse&gt;(request);<br>
<br>
  if (response.Succeeded)<br>
    return Optional&lt;Balance&gt;.Some(response.Content.Balance);<br>
  else if (response.StatusCode == 404)<br>
    return Optional&lt;Balance&gt;.None;<br>
  else<br>
    throw new BalanceFetchError(. . .);<br>
}</span></p>

<p class=MsoNormal>Likewise if updating a resource can fail due to concurrency
conflicts then it’s better to represent that in the interface so the caller stands
a better chance of realising they need to do more work than simply keep sending
the same request again and again. (<i>They</i> may choose to turn it into a
“conflict” exception type but that’s their judgement call.)</p>

<p class=MsoNormal>A key rationale for the split in the design is that the
domain-level proxy sits on top of the primitive-level proxy and therefore has
the opportunity to compensate for idiosyncrasies in the representation chosen
by the service so the caller gets a more cohesive interface. A common example
is where a web API chooses to represent domain errors by returning a <span
style='font-family:"Courier New"'>200</span> status code and a body instead of
using the preferred <span style='font-family:"Courier New"'>4XX</span> status
codes. In my recent article on monitoring [5] I gave another example of where a
<span style='font-family:"Courier New"'>400</span> status code was used instead
of a <span style='font-family:"Courier New"'>404</span> when a resource was
missing. In both these cases the normal REST semantics have been “abused” and
therefore we need to transform an apparent success or failure into the other
realm – it’s the job of the domain-level proxy to hide these kinds of edges. (If
the service provider ever releases a new version of the interface that corrects
these defects the domain interface should remain unaffected.)</p>

<p class=MsoNormal><span style='font-family:"Courier New"'>public Optional&lt;AccountId&gt;
LookupAccount(CardNumber cardNumber)<br>
{<br>
  var request = new LookupAccountRequest(cardNumber);<br>
  var response = primitiveProxy.Send&lt;LookupResponse&gt;(request);<br>
<br>
  if (response.Failed)<br>
    ThrowError(response);<br>
<br>
  if ( (response.StatusCode == 200)<br>
    &amp;&amp; (!response.Content.Error.IsEmpty()) )<br>
  {<br>
    throw new AccountLookupError(response.Content.Error);<br>
  }<br>
<br>
  return response.Content.AccountId.ToOptional();<br>
}</span></p>

<p class=MsoNormal>As we’ll see in a moment though the consumer always has the
possibility of dropping down a level if the richer interface doesn’t provide
the kind of semantics they’re looking for.</p>

<h2><span lang=X-NONE>The Primitive Interface</span></h2>

<p class=MsoNormal>While the outer layer focuses heavily on the happy path and
tries to make things easier for the consumer by leveraging the type system, the
inner layer provides a more raw experience whilst still shielding the caller
from all the gory details of the underlying transport mechanism. The aim is
still to provide a coherent API whilst at the same time giving them more control
over the various elements of the request and response when required.</p>

<p class=MsoNormal>Hence whereas the domain-level proxy will traffic in rich
domain types the primitive-level proxy will likely deal in basic structures and
string based values. The client will also have the option to control the
headers and URL if required, whilst using any additional building blocks
provided for those aspects they chose to adopt the default behaviour for.
Another classic Gang of Four pattern, Builder, can be used to provide full control
while helper methods can be added to get the ball rolling, e.g.</p>

<p class=MsoNormal><span style='font-family:"Courier New"'>public class FetchOrdersRequest<br>
{<br>
  public Headers Headers { get; }<br>
  public Content Content { get; }<br>
<br>
  public class Content<br>
  {<br>
    public string AccountId { get; set; }<br>
    public string FromDate { get; set; }<br>
    public string ToDate { get; set; }<br>
  }<br>
}<br>
<br>
public static FetchOrdersRequest BuildFetchOrdersRequest(this <br>
  ShopProxy proxy, AccountId accountId, Date from, Date to)<br>
{<br>
  return new FetchOrdersRequest<br>
  {<br>
    Headers = proxy.DefaultHeaders,<br>
    Content = new Content<br>
    {<br>
      AccountId = accountId.ToString(),<br>
      FromDate = from.ToIso8601(),<br>
      ToDate = to.ToIso8601(),<br>
    },<br>
  };<br>
}</span></p>

<p class=MsoNormal>When writing acceptance tests you usually want to create
various malformed requests to test your validation code, these require as much
of the request to be production-like as possible with only one aspect mutated
in each scenario. Hence to avoid false positives the test should leverage as
much of the real production code as possible to format the request whilst still
being able to tweak the one aspect under test. For example we might write a
test like this to check we only allow dates to be sent in ISO 8601 format:</p>

<p class=MsoNormal><span style='font-family:"Courier New"'>[Test]<br>
public void non_iso_8601_format_from_date_generates_an_error()<br>
{<br>
  // . . .<br>
  var request = new FindOrdersRequest(accountId, fromDate, toDate);<br>
  request.Content.FromDate = “01/01/2001”;<br>
<br>
  var response = proxy.Send&lt;FindOrdersResponse&gt;(request);<br>
<br>
  Assert.That(response.StatusCode, Is.EqualTo(400));<br>
  Assert.That(response.Error.Content, Does.Contain(“ISO-8601”));<br>
}</span></p>

<p class=MsoNormal>The approach to parsing the response and error handling will
also typically be more manual. Rather than throw exceptions the primitive-level
proxy will largely return composite values that contain both the successful result
and the error on failure. The caller then inspects the return value and queries
the relevant part of the structure and acts accordingly. In the case of a
successful request the body will contain the content, if any, whereas in the
failure scenario any combination of the result code, headers and body could be
used to formulate a richer error value. A complex result type for a JSON based
REST API might look something like this:</p>

<p class=MsoNormal><span style='font-family:"Courier New"'>public class HttpResult&lt;ContentType,
ErrorType&gt;<br>
{<br>
  public bool Succeeded { get; }<br>
  public int StatusCode { get; }<br>
<br>
  // On success.<br>
  public ContentType Content { get; }<br>
<br>
  // On failure.<br>
  public ErrorType Error { get; }<br>
<br>
  // For diagnostics.<br>
  public Headers Headers { get; }<br>
  public string Body { get; }<br>
}</span></p>

<p class=MsoNormal>Although we could have used an <span style='font-family:
"Courier New"'>Optional&lt;T&gt;</span> type for the success and error contents
and foregone the <span style='font-family:"Courier New"'>Succeeded</span>
property I’ve chosen instead to make those an implementation detail here (not
shown) and force the caller to query the <span style='font-family:"Courier New"'>Succeeded</span>
property to decide which content object should then be inspected – <span
style='font-family:"Courier New"'>Content</span> or <span style='font-family:
"Courier New"'>Error</span>.<br>
<br>
Network-level problems, such as failing to resolve the target hostname, could
be dealt with either way. On the one hand sticking entirely to exceptions or return
values makes for a more consistent interface however in reality these low-level
failures may be outside the remit of what you’re trying to allow recovery of,
just like an out-of-memory issue. (In the enterprise arena where I’ve applied
this approach the only recovery from network issues is essentially to “wait it
out”. Host configuration errors can usually be spotted at deployment time by
proactively probing during service start-up.)</p>

<h1><span lang=X-NONE>Summary</span></h1>

<p class=MsoNormal>Like any design pattern this is a solution to a problem in a
particular context. If your context is building a service for which you intend
to write some client code in a number of different guises, such as acceptance
tests or other tooling, where you will likely need a mixture of high-level and
lower-level interaction, then splitting your proxy in half may make sense. Naturally
you should be wary of over-engineering your design, however at the same time
keep an eye out to see if you can reduce some complexity on the client-side by removing
a little duplication before it becomes irreversible.</p>

<h1><span lang=X-NONE>References</span></h1>

<p class=MsoNormal>[1] Test Pyramid, Martin Fowler,<br>
<a href="https://martinfowler.com/bliki/TestPyramid.html">https://martinfowler.com/bliki/TestPyramid.html</a>
</p>

<p class=MsoNormal>[2] TDD - From the Inside Out or the Outside In?, Georgina
Mcfadyen,<br>
<a
href="https://8thlight.com/blog/georgina-mcfadyen/2016/06/27/inside-out-tdd-vs-outside-in.html">https://8thlight.com/blog/georgina-mcfadyen/2016/06/27/inside-out-tdd-vs-outside-in.html</a>
</p>

<p class=MsoNormal>[3] Simple Instrumentation, Chris Oldwood, Overload 116,<br>
<a href="https://accu.org/index.php/journals/1843">https://accu.org/index.php/journals/1843</a>
</p>

<p class=MsoNormal>[4] In The Toolbox - Libraries, Console Apps &amp; GUIs,
Chris Oldwood, C Vu 30-2,<br>
<a
href="http://www.chrisoldwood.com/articles/in-the-toolbox-libraries-console-apps-and-guis.html">http://www.chrisoldwood.com/articles/in-the-toolbox-libraries-console-apps-and-guis.html</a>
</p>

<p class=MsoNormal>[5] The Curse of NTLM Based HTTP Proxies, Chris Oldwood,<br>
<a
href="http://chrisoldwood.blogspot.com/2016/05/the-curse-of-ntlm-based-http-proxies.html">http://chrisoldwood.blogspot.com/2016/05/the-curse-of-ntlm-based-http-proxies.html</a>
</p>

<p class=MsoNormal>[6] Causality - Relating Distributed Diagnostic Contexts,
Chris Oldwood, Overload 114,<br>
<a href="https://accu.org/index.php/journals/1870">https://accu.org/index.php/journals/1870</a>
</p>

<p class=MsoNormal> [7] Monitoring: Turning Noise into Signal, Chris Oldwood,
Overload 144,<br>
<a href="https://accu.org/index.php/journals/2488">https://accu.org/index.php/journals/2488</a>
</p>

<p class=MsoNormal>[8] Primitive Domain Types - Too Much Like Hard Work?, Chris
Oldwood,<br>
<a
href="http://chrisoldwood.blogspot.com/2012/11/primitive-domain-types-too-much-like.html">http://chrisoldwood.blogspot.com/2012/11/primitive-domain-types-too-much-like.html</a>
</p>

<p class=MsoNormal>[9] PrimitiveObsession, C2 Wiki,<br>
<a href="http://wiki.c2.com/?PrimitiveObsession">http://wiki.c2.com/?PrimitiveObsession</a>
</p>

<p class=MsoNormal>[10] Simplicity Before Generality, Use Before Reuse, Kevlin
Henney,<br>
<a
href="https://medium.com/@kevlinhenney/simplicity-before-generality-use-before-reuse-722a8f967eb9">https://medium.com/@kevlinhenney/simplicity-before-generality-use-before-reuse-722a8f967eb9</a>
</p>

<p class=MsoNormal>[11] Design Patterns: Elements of Reusable Object-Oriented
Software, Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides,<br>
<a href="https://en.wikipedia.org/wiki/Design_Patterns">https://en.wikipedia.org/wiki/Design_Patterns</a>
</p>

<p class=MsoNormal>Chris Oldwood<br>
16 June 2018</p>

<h3><span lang=X-NONE>Biography</span></h3>

<p class=MsoNormal>Chris is a freelance programmer who started out as a bedroom
coder in the 80’s writing assembler on 8-bit micros. These days it's enterprise
grade technology in plush corporate offices. He also commentates on the
Godmanchester duck race and can be easily distracted via gort@cix.co.uk or
@chrisoldwood.</p>

</div>

</body>

</html>
